{
  "version": 3,
  "sources": ["utils/error-handler.ts", "components/echo-tool.ts", "components/metrics-dashboard.ts", "components/event-stream.ts", "components/notification-system.ts", "components/tool-executor.ts", "components/htmx-alpine-bridge.ts", "components/dashboard-controls.ts", "alpine-components.ts"],
  "sourcesContent": ["// Centralized Error Handling Utilities\n\nimport { ErrorDetails } from '../types/alpine';\n\n/**\n * Standard error types for the application\n */\nexport const ERROR_TYPES = {\n    VALIDATION: 'validation' as const,\n    NETWORK: 'network' as const,\n    SECURITY: 'security' as const,\n    SYSTEM: 'system' as const,\n    USER: 'user' as const,\n    UNKNOWN: 'unknown' as const\n} as const;\n\n/**\n * Error severity levels\n */\nexport const ERROR_SEVERITY = {\n    LOW: 'low' as const,\n    MEDIUM: 'medium' as const,\n    HIGH: 'high' as const,\n    CRITICAL: 'critical' as const\n} as const;\n\n// Type aliases for easier use\nexport type ErrorType = typeof ERROR_TYPES[keyof typeof ERROR_TYPES];\nexport type ErrorSeverity = typeof ERROR_SEVERITY[keyof typeof ERROR_SEVERITY];\n\n// Enhanced type guards for error classification\nexport function isValidationError(error: Error): boolean {\n    const validationKeywords = [\n        'validation', 'invalid', 'required', 'missing', 'empty', 'null', 'undefined',\n        'format', 'syntax', 'parse', 'malformed', 'expected', 'must be', 'cannot be',\n        'too short', 'too long', 'out of range', 'not allowed', 'schema', 'type error'\n    ];\n    \n    const message = error.message.toLowerCase();\n    const name = error.name.toLowerCase();\n    \n    return validationKeywords.some(keyword => \n        message.includes(keyword) || name.includes(keyword)\n    ) || error.name === 'TypeError' || error.name === 'SyntaxError';\n}\n\nexport function isNetworkError(error: Error): boolean {\n    const networkKeywords = [\n        'network', 'fetch', 'request', 'response', 'connection', 'timeout', 'abort',\n        'offline', 'cors', 'http', 'ssl', 'tls', 'dns', 'socket', 'refused',\n        'unreachable', 'gateway', 'proxy', 'status 4', 'status 5'\n    ];\n    \n    const message = error.message.toLowerCase();\n    const name = error.name.toLowerCase();\n    \n    return networkKeywords.some(keyword => \n        message.includes(keyword) || name.includes(keyword)\n    ) || /failed to fetch|network error|load failed/i.test(error.message);\n}\n\nexport function isSecurityError(error: Error): boolean {\n    const securityKeywords = [\n        'security', 'permission', 'unauthorized', 'forbidden', 'access denied',\n        'authentication', 'authorization', 'token', 'csrf', 'xss', 'injection',\n        'blocked', 'restricted', 'credentials', 'login', 'session expired'\n    ];\n    \n    const message = error.message.toLowerCase();\n    const name = error.name.toLowerCase();\n    \n    return securityKeywords.some(keyword => \n        message.includes(keyword) || name.includes(keyword)\n    ) || /status 40[13]/i.test(error.message); // 401, 403 status codes\n}\n\nexport function isSystemError(error: Error): boolean {\n    const systemKeywords = [\n        'memory', 'disk', 'file system', 'database', 'server', 'internal',\n        'crash', 'overflow', 'stack', 'heap', 'resource', 'quota', 'limit',\n        'unavailable', 'maintenance', 'overload', 'capacity'\n    ];\n    \n    const message = error.message.toLowerCase();\n    const name = error.name.toLowerCase();\n    \n    return systemKeywords.some(keyword => \n        message.includes(keyword) || name.includes(keyword)\n    ) || /status 50\\d/i.test(error.message) || // 5xx status codes\n       error.name === 'RangeError' || error.name === 'ReferenceError';\n}\n\nexport function isUserError(error: Error): boolean {\n    const userKeywords = [\n        'user', 'input', 'action', 'operation', 'cancelled', 'aborted',\n        'interrupted', 'duplicate', 'already exists', 'not found', 'empty result'\n    ];\n    \n    const message = error.message.toLowerCase();\n    const name = error.name.toLowerCase();\n    \n    return userKeywords.some(keyword => \n        message.includes(keyword) || name.includes(keyword)\n    ) || /status 404|status 409|status 410/i.test(error.message); // 404, 409, 410 status codes\n}\n\n/**\n * Standard error response structure\n */\nexport class StandardError extends Error {\n    public readonly name: string = 'StandardError';\n    public readonly type: ErrorType;\n    public readonly severity: ErrorSeverity;\n    public readonly details: ErrorDetails;\n    public readonly timestamp: string;\n    public readonly userMessage: string;\n\n    constructor(\n        message: string,\n        type: ErrorType = ERROR_TYPES.UNKNOWN,\n        severity: ErrorSeverity = ERROR_SEVERITY.MEDIUM,\n        details: ErrorDetails = {}\n    ) {\n        super(message);\n        this.type = type;\n        this.severity = severity;\n        this.details = details;\n        this.timestamp = new Date().toISOString();\n        this.userMessage = this.getUserFriendlyMessage();\n    }\n\n    /**\n     * Get user-friendly error message\n     */\n    getUserFriendlyMessage(): string {\n        const friendlyMessages: Record<ErrorType, string> = {\n            [ERROR_TYPES.VALIDATION]: 'Please check your input and try again.',\n            [ERROR_TYPES.NETWORK]: 'Network connection issue. Please try again.',\n            [ERROR_TYPES.SECURITY]: 'Security error. Please contact support.',\n            [ERROR_TYPES.SYSTEM]: 'System error. Please try again later.',\n            [ERROR_TYPES.USER]: this.message,\n            [ERROR_TYPES.UNKNOWN]: 'An unexpected error occurred. Please try again.'\n        };\n\n        return friendlyMessages[this.type] || friendlyMessages[ERROR_TYPES.UNKNOWN];\n    }\n\n    /**\n     * Convert error to JSON format\n     */\n    toJSON(): Record<string, any> {\n        return {\n            name: this.name,\n            message: this.message,\n            type: this.type,\n            severity: this.severity,\n            details: this.details,\n            timestamp: this.timestamp,\n            userMessage: this.userMessage\n        };\n    }\n}\n\n/**\n * Error handler utility class\n */\nexport class ErrorHandler {\n    /**\n     * Sanitize stack traces for production environments\n     */\n    static sanitizeStackTrace(stack?: string): string | undefined {\n        if (!stack) return undefined;\n        \n        // In production, sanitize stack traces to prevent information leakage\n        if (process.env.NODE_ENV === 'production') {\n            // Remove file paths and only keep function/error names\n            return stack\n                .split('\\n')\n                .map(line => {\n                    // Keep the error message line\n                    if (!line.trim().startsWith('at ')) {\n                        return line;\n                    }\n                    \n                    // For stack frames, remove file paths and line numbers\n                    const match = line.match(/at\\s+([^(]+)/);\n                    if (match) {\n                        return `    at ${match[1].trim()}`;\n                    }\n                    \n                    return '    at <sanitized>';\n                })\n                .slice(0, 5) // Limit to first 5 frames\n                .join('\\n');\n        }\n        \n        // In development, return full stack trace\n        return stack;\n    }\n\n    /**\n     * Create validation error\n     */\n    static createValidationError(message: string, details: ErrorDetails = {}): StandardError {\n        return new StandardError(message, ERROR_TYPES.VALIDATION, ERROR_SEVERITY.LOW, details);\n    }\n\n    /**\n     * Create network error\n     */\n    static createNetworkError(message: string, details: ErrorDetails = {}): StandardError {\n        return new StandardError(message, ERROR_TYPES.NETWORK, ERROR_SEVERITY.MEDIUM, details);\n    }\n\n    /**\n     * Create security error\n     */\n    static createSecurityError(message: string, details: ErrorDetails = {}): StandardError {\n        return new StandardError(message, ERROR_TYPES.SECURITY, ERROR_SEVERITY.HIGH, details);\n    }\n\n    /**\n     * Create system error\n     */\n    static createSystemError(message: string, details: ErrorDetails = {}): StandardError {\n        return new StandardError(message, ERROR_TYPES.SYSTEM, ERROR_SEVERITY.MEDIUM, details);\n    }\n\n    /**\n     * Create user error\n     */\n    static createUserError(message: string, details: ErrorDetails = {}): StandardError {\n        return new StandardError(message, ERROR_TYPES.USER, ERROR_SEVERITY.LOW, details);\n    }\n\n    /**\n     * Get error category and suggestions based on error type\n     */\n    static getErrorAnalysis(error: StandardError): {\n        category: string;\n        suggestions: string[];\n        isRecoverable: boolean;\n        userAction: string;\n    } {\n        const analysisMap = {\n            [ERROR_TYPES.VALIDATION]: {\n                category: 'Input Validation',\n                suggestions: [\n                    'Check that all required fields are filled',\n                    'Verify data format matches expected pattern',\n                    'Ensure values are within acceptable ranges'\n                ],\n                isRecoverable: true,\n                userAction: 'Please correct your input and try again'\n            },\n            [ERROR_TYPES.NETWORK]: {\n                category: 'Network/Connectivity',\n                suggestions: [\n                    'Check your internet connection',\n                    'Try refreshing the page',\n                    'Check if the server is accessible',\n                    'Verify proxy/firewall settings'\n                ],\n                isRecoverable: true,\n                userAction: 'Please check your connection and retry'\n            },\n            [ERROR_TYPES.SECURITY]: {\n                category: 'Security/Authentication',\n                suggestions: [\n                    'Verify your login credentials',\n                    'Check if your session has expired',\n                    'Ensure you have proper permissions',\n                    'Contact administrator if needed'\n                ],\n                isRecoverable: false,\n                userAction: 'Authentication required - please log in again'\n            },\n            [ERROR_TYPES.SYSTEM]: {\n                category: 'System/Server',\n                suggestions: [\n                    'Wait a moment and try again',\n                    'Check system status page',\n                    'Contact technical support',\n                    'Save your work and restart the application'\n                ],\n                isRecoverable: false,\n                userAction: 'System issue detected - please try again later'\n            },\n            [ERROR_TYPES.USER]: {\n                category: 'User Operation',\n                suggestions: [\n                    'Review the requested operation',\n                    'Check if the resource exists',\n                    'Verify you have the right permissions',\n                    'Try a different approach'\n                ],\n                isRecoverable: true,\n                userAction: 'Please review your action and try again'\n            },\n            [ERROR_TYPES.UNKNOWN]: {\n                category: 'Unknown',\n                suggestions: [\n                    'Try refreshing the page',\n                    'Check browser console for details',\n                    'Contact support with error details',\n                    'Try again in a few minutes'\n                ],\n                isRecoverable: true,\n                userAction: 'Unexpected error - please try again'\n            }\n        };\n\n        return analysisMap[error.type] || analysisMap[ERROR_TYPES.UNKNOWN];\n    }\n\n    /**\n     * Handle and normalize any error\n     */\n    static handleError(error: Error | string | unknown, context: string = 'unknown'): StandardError {\n        if (error instanceof StandardError) {\n            return error;\n        }\n\n        let message = 'An unexpected error occurred';\n        let type: ErrorType = ERROR_TYPES.UNKNOWN;\n        let severity: ErrorSeverity = ERROR_SEVERITY.MEDIUM;\n        const details: ErrorDetails = { context };\n\n        if (error instanceof Error) {\n            message = error.message;\n            details.originalError = error.name;\n            details.stack = this.sanitizeStackTrace(error.stack);\n            \n            // Enhanced error classification using expanded type guards\n            if (isValidationError(error)) {\n                type = ERROR_TYPES.VALIDATION;\n                severity = ERROR_SEVERITY.LOW;\n            } else if (isNetworkError(error)) {\n                type = ERROR_TYPES.NETWORK;\n                severity = ERROR_SEVERITY.MEDIUM;\n            } else if (isSecurityError(error)) {\n                type = ERROR_TYPES.SECURITY;\n                severity = ERROR_SEVERITY.HIGH;\n            } else if (isSystemError(error)) {\n                type = ERROR_TYPES.SYSTEM;\n                severity = ERROR_SEVERITY.HIGH;\n            } else if (isUserError(error)) {\n                type = ERROR_TYPES.USER;\n                severity = ERROR_SEVERITY.LOW;\n            }\n        } else if (typeof error === 'string') {\n            message = error;\n        } else if (error !== null && error !== undefined) {\n            // Handle other types of errors (objects, arrays, etc.)\n            if (typeof error === 'object') {\n                message = 'An unexpected error occurred';\n                details.originalError = error.toString();\n            } else {\n                message = String(error);\n            }\n        }\n\n        return new StandardError(message, type, severity, details);\n    }\n\n    /**\n     * Log error with appropriate level\n     */\n    static logError(error: StandardError, component: string = 'unknown'): void {\n        const logData = {\n            component,\n            error: error.toJSON(),\n            timestamp: new Date().toISOString()\n        };\n\n        switch (error.severity) {\n            case ERROR_SEVERITY.CRITICAL:\n                console.error('\uD83D\uDEA8 CRITICAL ERROR:', logData);\n                break;\n            case ERROR_SEVERITY.HIGH:\n                console.error('\u274C HIGH ERROR:', logData);\n                break;\n            case ERROR_SEVERITY.MEDIUM:\n                console.warn('\u26A0\uFE0F MEDIUM ERROR:', logData);\n                break;\n            case ERROR_SEVERITY.LOW:\n                console.info('\u2139\uFE0F LOW ERROR:', logData);\n                break;\n            default:\n                console.error('\u2753 UNKNOWN ERROR:', logData);\n        }\n    }\n\n    /**\n     * Show error to user via notification system\n     */\n    static showErrorToUser(error: StandardError, component: string = 'unknown'): void {\n        if (typeof window !== 'undefined' && window.Alpine?.store('notifications')) {\n            let notificationType: 'error' | 'warning' | 'info' = 'error';\n            \n            switch (error.severity) {\n                case ERROR_SEVERITY.CRITICAL:\n                case ERROR_SEVERITY.HIGH:\n                    notificationType = 'error';\n                    break;\n                case ERROR_SEVERITY.MEDIUM:\n                    notificationType = 'warning';\n                    break;\n                case ERROR_SEVERITY.LOW:\n                    notificationType = 'info';\n                    break;\n            }\n\n            const notificationStore = window.Alpine.store('notifications') as any;\n            notificationStore.add(\n                error.userMessage,\n                notificationType,\n                error.severity === ERROR_SEVERITY.CRITICAL ? 10000 : 5000\n            );\n        }\n\n        // Also add to error boundary store if available\n        if (typeof window !== 'undefined' && window.Alpine?.store('errorBoundary')) {\n            const errorBoundaryStore = window.Alpine.store('errorBoundary') as any;\n            errorBoundaryStore.addError(error, component, 'unknown');\n        }\n    }\n\n    /**\n     * Process error through complete error handling pipeline\n     */\n    static processError(error: Error | string | unknown, component: string = 'unknown', context: string = 'unknown'): StandardError {\n        const standardError = this.handleError(error, context);\n        \n        this.logError(standardError, component);\n        this.showErrorToUser(standardError, component);\n        \n        return standardError;\n    }\n}\n\n/**\n * Operation function type for retry operations\n */\ntype RetryableOperation<T> = () => Promise<T>;\n\n/**\n * Circuit breaker function type\n */\ntype CircuitBreakerOperation<T extends any[], R> = (...args: T) => Promise<R>;\n\n/**\n * Error recovery utilities\n */\nexport class ErrorRecovery {\n    /**\n     * Retry operation with exponential backoff\n     */\n    static async retry<T>(\n        operation: RetryableOperation<T>,\n        maxRetries: number = 3,\n        baseDelay: number = 1000\n    ): Promise<T> {\n        let lastError: unknown;\n        \n        for (let attempt = 0; attempt < maxRetries; attempt++) {\n            try {\n                return await operation();\n            } catch (error) {\n                lastError = error;\n                \n                if (attempt === maxRetries - 1) {\n                    throw ErrorHandler.handleError(error, 'retry_failed');\n                }\n                \n                // Exponential backoff\n                const delay = baseDelay * Math.pow(2, attempt);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            }\n        }\n        \n        throw ErrorHandler.handleError(lastError, 'retry_exhausted');\n    }\n\n    /**\n     * Circuit breaker pattern for error handling\n     */\n    static createCircuitBreaker<T extends any[], R>(\n        operation: CircuitBreakerOperation<T, R>,\n        failureThreshold: number = 5,\n        resetTimeout: number = 60000\n    ): CircuitBreakerOperation<T, R> {\n        let state: 'closed' | 'open' | 'half-open' = 'closed';\n        let failureCount = 0;\n        let lastFailureTime = 0;\n\n        return async function(...args: T): Promise<R> {\n            if (state === 'open') {\n                if (Date.now() - lastFailureTime > resetTimeout) {\n                    state = 'half-open';\n                } else {\n                    throw ErrorHandler.createSystemError('Circuit breaker is open');\n                }\n            }\n\n            try {\n                const result = await operation(...args);\n                \n                if (state === 'half-open') {\n                    state = 'closed';\n                    failureCount = 0;\n                }\n                \n                return result;\n            } catch (error) {\n                failureCount++;\n                lastFailureTime = Date.now();\n                \n                if (failureCount >= failureThreshold) {\n                    state = 'open';\n                }\n                \n                throw ErrorHandler.handleError(error, 'circuit_breaker');\n            }\n        };\n    }\n}\n\n/**\n * Global error handler setup\n */\nexport function setupGlobalErrorHandling(): void {\n    if (typeof window === 'undefined') return;\n\n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event: PromiseRejectionEvent) => {\n        const error = ErrorHandler.processError(\n            event.reason,\n            'global',\n            'unhandledrejection'\n        );\n        \n        console.error('Unhandled promise rejection:', error);\n        event.preventDefault();\n    });\n\n    // Handle global errors\n    window.addEventListener('error', (event: ErrorEvent) => {\n        const error = ErrorHandler.processError(\n            event.error || event.message,\n            'global',\n            'global_error'\n        );\n        \n        console.error('Global error:', error);\n    });\n\n    // Handle Alpine.js errors if available\n    document.addEventListener('alpine:error', (event: Event) => {\n        const customEvent = event as CustomEvent;\n        const error = ErrorHandler.processError(\n            customEvent.detail.error,\n            'alpine',\n            'alpine_error'\n        );\n        \n        console.error('Alpine.js error:', error);\n    });\n}\n\n// Auto-setup global error handling\nif (typeof window !== 'undefined') {\n    setupGlobalErrorHandling();\n}", "// Echo Tool Alpine.js Component\n\nimport type * as Alpine from 'alpinejs';\nimport { ErrorHandler, ERROR_TYPES } from '../utils/error-handler';\nimport { CustomAlpineComponent } from '../types/alpine';\n\n// Validation result interface\ninterface ValidationResult {\n    valid: boolean;\n    errors: string[];\n    sanitized: string;\n}\n\n// Tool executor interface (simplified)\ninterface ToolExecutor {\n    loading: boolean;\n    executionHistory: any[];\n    lastResult: any;\n    execute(args: Record<string, any>): Promise<any>;\n    clearHistory(): void;\n    getSuccessRate(): number;\n    getAverageExecutionTime(): number;\n}\n\n// Echo tool component data interface\ninterface EchoToolData {\n    message: string;\n    result: string | null;\n    executionTime: string | null;\n    errors: Record<string, string>;\n    executor: ToolExecutor | null;\n    loading: boolean;\n    executionHistory: any[];\n    \n    init(): void;\n    validateAndSanitizeInput(input: string): ValidationResult;\n    execute(): Promise<void>;\n    handleExecutionError(error: Error): void;\n    validateForm(): boolean;\n    clearHistory(): void;\n    getSuccessRate(): number;\n    getAverageExecutionTime(): number;\n}\n\n/**\n * Echo Tool Alpine.js Component\n * \n * This component provides a simple echo tool interface for the MCP Dashboard.\n * It handles input validation, sanitization, and execution of echo commands\n * with proper error handling and user feedback.\n */\nexport function echoTool(): CustomAlpineComponent<EchoToolData> {\n    return {\n        /** The input message to echo */\n        message: 'Hello from the MCP Dashboard!',\n        \n        /** The result of the last echo execution */\n        result: null,\n        \n        /** The execution time of the last command */\n        executionTime: null,\n        \n        /** Form validation errors */\n        errors: {},\n        \n        /** The tool executor instance */\n        executor: null,\n        \n        /**\n         * Validates and sanitizes user input for security\n         */\n        validateAndSanitizeInput(input: string): ValidationResult {\n            const errors: string[] = [];\n            \n            if (!input || typeof input !== 'string') {\n                errors.push('Message must be a non-empty string');\n                return { valid: false, errors, sanitized: '' };\n            }\n            \n            // Length validation\n            if (input.length > 1000) {\n                errors.push('Message too long (max 1000 characters)');\n            }\n            \n            // Check for potentially dangerous patterns\n            const dangerousPatterns = [\n                /<script[^>]*>/i,\n                /javascript:/i,\n                /vbscript:/i,\n                /onload\\s*=/i,\n                /onerror\\s*=/i\n            ];\n            \n            for (const pattern of dangerousPatterns) {\n                if (pattern.test(input)) {\n                    errors.push('Message contains potentially dangerous content');\n                    break;\n                }\n            }\n            \n            return {\n                valid: errors.length === 0,\n                errors,\n                sanitized: input.trim()\n            };\n        },\n        \n        /**\n         * Initialize the component\n         * Sets up the tool executor instance from the Alpine store\n         */\n        init(): void {\n            // Initialize the tool executor\n            this.executor = this.$store.toolExecution.getExecutor('echo');\n        },\n        \n        /**\n         * Get the current loading state of the tool executor\n         */\n        get loading(): boolean {\n            return this.executor ? this.executor.loading : false;\n        },\n        \n        /**\n         * Get the execution history from the tool executor\n         */\n        get executionHistory(): any[] {\n            return this.executor ? this.executor.executionHistory : [];\n        },\n        \n        /**\n         * Execute the echo tool with the current message\n         * \n         * Validates input, executes the tool, and handles the response.\n         * Updates the result and execution time on success, or shows errors on failure.\n         */\n        async execute(): Promise<void> {\n            try {\n                if (!this.validateForm()) return;\n                \n                if (!this.executor) {\n                    this.executor = this.$store.toolExecution?.getExecutor('echo');\n                    if (!this.executor) {\n                        throw new Error('Tool executor not available');\n                    }\n                }\n                \n                const result = await this.executor.execute({ message: this.message });\n                \n                if (result.success) {\n                    this.result = JSON.stringify(result.result, null, 2);\n                    this.executionTime = `Executed in ${this.executor.lastResult?.duration || 0}ms`;\n                } else {\n                    this.result = null;\n                    this.executionTime = null;\n                    \n                    // Show error to user\n                    if (this.$store.notifications) {\n                        this.$store.notifications.add(\n                            `Tool execution failed: ${result.error || 'Unknown error'}`,\n                            'error'\n                        );\n                    }\n                }\n                \n            } catch (error) {\n                this.handleExecutionError(error as Error);\n            }\n        },\n        \n        /**\n         * Handle execution errors with centralized error processing\n         */\n        handleExecutionError(error: Error): void {\n            // Use centralized error handling\n            const standardError = ErrorHandler.processError(\n                error,\n                'echoTool',\n                'execute'\n            );\n            \n            this.result = null;\n            this.executionTime = null;\n            \n            // For user errors, show the original message\n            if (error.message && error.message.includes('validation')) {\n                const validationError = ErrorHandler.createValidationError(\n                    'Please check your input and try again.',\n                    { originalError: error.message }\n                );\n                ErrorHandler.showErrorToUser(validationError, 'echoTool');\n            }\n        },\n        \n        /**\n         * Validate the form input before execution\n         */\n        validateForm(): boolean {\n            this.errors = {};\n            \n            const validation = this.validateAndSanitizeInput(this.message);\n            \n            if (!validation.valid) {\n                this.errors.message = validation.errors.join(', ');\n                return false;\n            }\n            \n            // Update message with sanitized version\n            this.message = validation.sanitized;\n            return true;\n        },\n        \n        /**\n         * Clear the execution history\n         * \n         * Clears all previous execution results from the tool executor.\n         * Handles any errors that occur during the clearing process.\n         */\n        clearHistory(): void {\n            try {\n                if (this.executor) {\n                    this.executor.clearHistory();\n                }\n            } catch (error) {\n                ErrorHandler.processError(error, 'echoTool', 'clearHistory');\n            }\n        },\n        \n        /**\n         * Get the success rate of tool executions\n         */\n        getSuccessRate(): number {\n            try {\n                return this.executor ? this.executor.getSuccessRate() : 0;\n            } catch (error) {\n                ErrorHandler.processError(error, 'echoTool', 'getSuccessRate');\n                return 0;\n            }\n        },\n        \n        /**\n         * Get the average execution time of tool executions\n         */\n        getAverageExecutionTime(): number {\n            try {\n                return this.executor ? this.executor.getAverageExecutionTime() : 0;\n            } catch (error) {\n                ErrorHandler.processError(error, 'echoTool', 'getAverageExecutionTime');\n                return 0;\n            }\n        }\n    } as CustomAlpineComponent<EchoToolData>;\n}\n\n// Export types for testing and module usage\nexport type EchoToolComponent = CustomAlpineComponent<EchoToolData>;\nexport { ToolExecutor };", "// Metrics Dashboard Alpine.js Component\n\nimport type * as Alpine from 'alpinejs';\nimport { MetricsData, CustomAlpineComponent } from '../types/alpine';\nimport { ErrorHandler, ERROR_TYPES } from '../utils/error-handler';\n\n// Backend metrics structure (matches Rust DashboardMetrics)\ninterface DashboardMetrics {\n    total_tool_calls: number;\n    success_rate: number;\n    active_sessions: number;\n    avg_duration_ms: number;\n    tools_available: number;\n    resources_available: number;\n}\n\n// Metrics component data interface\ninterface MetricsStoreData {\n    metrics: DashboardMetrics;\n    loading: boolean;\n    initializeUpdates(): void;\n    updateMetrics(event: { detail: { xhr: { response: string } } }): void;\n}\n\n/**\n * Metrics Dashboard Alpine.js Component\n * \n * This component provides a dashboard interface for displaying system metrics\n * and performance data. It integrates with the metrics store to manage real-time\n * data updates and loading states.\n */\nexport function metricsStore(): CustomAlpineComponent<MetricsStoreData> {\n    return {\n        /**\n         * Get the current metrics data from the store\n         */\n        get metrics(): DashboardMetrics {\n            return this.$store.metrics.data;\n        },\n        \n        /**\n         * Get the current loading state from the store\n         */\n        get loading(): boolean {\n            return this.$store.metrics.loading;\n        },\n        \n        /**\n         * Initialize metrics updates by setting loading state\n         */\n        initializeUpdates(): void {\n            this.$store.metrics.setLoading(true);\n        },\n        \n        /**\n         * Update metrics data from an event\n         */\n        updateMetrics(event: { detail: { xhr: { response: string } } }): void {\n            try {\n                const data = JSON.parse(event.detail.xhr.response);\n                this.$store.metrics.update(data);\n            } catch (error) {\n                const standardError = ErrorHandler.processError(\n                    error as Error,\n                    'metricsStore',\n                    'updateMetrics_json_parsing'\n                );\n                ErrorHandler.showErrorToUser(standardError, 'metricsStore');\n                this.$store.metrics.setLoading(false);\n            }\n        }\n    } as CustomAlpineComponent<MetricsStoreData>;\n}\n\n// Enhanced metrics store interface (for the store itself)\ninterface MetricsStore {\n    data: DashboardMetrics;\n    loading: boolean;\n    error: string | null;\n    history: MetricsData[];\n    update(newData: DashboardMetrics): void;\n    setLoading(state: boolean): void;\n    setError(error: string | null): void;\n    addMetric(metric: MetricsData): void;\n    clear(): void;\n    getByType(type: string): MetricsData[];\n    getLatest(type: string): MetricsData | undefined;\n    getMetricsInRange(startTime: number, endTime: number): MetricsData[];\n    getAverageValue(type: string): number;\n}\n\n/**\n * Metrics store - using Alpine.js init event\n * \n * Global Alpine.js store for managing system metrics data.\n * Provides methods to update metrics data and manage loading states.\n */\nif (typeof document !== 'undefined') {\n    document.addEventListener('alpine:init', () => {\n    if (typeof window !== 'undefined' && window.Alpine) {\n        window.Alpine.store('metrics', {\n            /** Current metrics data */\n            data: {\n                total_tool_calls: 0,\n                success_rate: 0,\n                active_sessions: 0,\n                avg_duration_ms: 0,\n                tools_available: 0,\n                resources_available: 0\n            } as DashboardMetrics,\n            \n            /** Loading state indicator */\n            loading: false,\n            \n            /** Error state */\n            error: null as string | null,\n            \n            /** Historical metrics data */\n            history: [] as MetricsData[],\n            \n            /**\n             * Update metrics data with new values\n             */\n            update(newData: DashboardMetrics): void {\n                this.data = { ...this.data, ...newData };\n                this.loading = false;\n                \n                // Add timestamp for historical tracking\n                this.addMetric({\n                    timestamp: Date.now(),\n                    value: newData.total_tool_calls,\n                    type: 'update',\n                    total_tool_calls: newData.total_tool_calls,\n                    success_rate: newData.success_rate\n                });\n            },\n            \n            /**\n             * Set the loading state\n             */\n            setLoading(state: boolean): void {\n                this.loading = state;\n            },\n            \n            /**\n             * Set the error state\n             */\n            setError(error: string | null): void {\n                this.error = error;\n            },\n            \n            /**\n             * Add a metric to the history\n             */\n            addMetric(metric: MetricsData): void {\n                this.history.push(metric);\n                \n                // Keep only last 100 metrics to prevent memory issues\n                if (this.history.length > 100) {\n                    this.history.shift();\n                }\n            },\n            \n            /**\n             * Clear all metrics data\n             */\n            clear(): void {\n                this.data = {\n                    total_tool_calls: 0,\n                    success_rate: 0,\n                    active_sessions: 0,\n                    avg_duration_ms: 0,\n                    tools_available: 0,\n                    resources_available: 0\n                };\n                this.history = [];\n                this.loading = false;\n                this.error = null;\n            },\n            \n            /**\n             * Get metrics by type\n             */\n            getByType(type: string): MetricsData[] {\n                return this.history.filter(metric => metric.type === type);\n            },\n            \n            /**\n             * Get the latest metric of a specific type\n             */\n            getLatest(type: string): MetricsData | undefined {\n                const metrics = this.getByType(type);\n                return metrics.length > 0 ? metrics[metrics.length - 1] : undefined;\n            },\n            \n            /**\n             * Get metrics within a time range\n             */\n            getMetricsInRange(startTime: number, endTime: number): MetricsData[] {\n                return this.history.filter(metric => \n                    metric.timestamp >= startTime && metric.timestamp <= endTime\n                );\n            },\n            \n            /**\n             * Calculate average value for a metric type\n             */\n            getAverageValue(type: string): number {\n                const metrics = this.getByType(type);\n                if (metrics.length === 0) return 0;\n                \n                const sum = metrics.reduce((acc, metric) => acc + metric.value, 0);\n                return sum / metrics.length;\n            }\n        } as MetricsStore);\n    }\n    });\n}\n\n// Export type for testing and module usage\nexport type MetricsStoreComponent = CustomAlpineComponent<MetricsStoreData>;\n\n// Full metrics dashboard component data interface\ninterface MetricsDashboardData {\n    refreshInterval: number;\n    autoRefresh: boolean;\n    lastRefresh: string | null;\n    _refreshTimer: NodeJS.Timeout | null;\n    metrics: DashboardMetrics;\n    loading: boolean;\n    error: string | null;\n    init(): void;\n    destroy(): void;\n    startAutoRefresh(): void;\n    stopAutoRefresh(): void;\n    refresh(): Promise<void>;\n    formatUptime(seconds: number): string;\n    formatMemoryUsage(bytes: number): string;\n    getStatusColor(status: string): string;\n}\n\n/**\n * Full Metrics Dashboard Component\n * \n * This component provides a complete dashboard interface for system metrics\n * with auto-refresh, error handling, and display formatting.\n */\nexport function metricsDashboard(): CustomAlpineComponent<MetricsDashboardData> {\n    return {\n        refreshInterval: 30000,\n        autoRefresh: true,\n        lastRefresh: null as string | null,\n        _refreshTimer: null as NodeJS.Timeout | null,\n        \n        get metrics() {\n            return this.$store.metrics.data;\n        },\n        \n        get loading() {\n            return this.$store.metrics.loading;\n        },\n        \n        get error() {\n            return (this.$store.metrics as any).error || null;\n        },\n        \n        init() {\n            this.startAutoRefresh();\n        },\n        \n        destroy() {\n            this.stopAutoRefresh();\n        },\n        \n        startAutoRefresh() {\n            if (this.autoRefresh) {\n                this._refreshTimer = setInterval(() => {\n                    this.refresh();\n                }, this.refreshInterval);\n            }\n        },\n        \n        stopAutoRefresh() {\n            if (this._refreshTimer) {\n                clearInterval(this._refreshTimer);\n                this._refreshTimer = null;\n            }\n        },\n        \n        async refresh() {\n            try {\n                this.$store.metrics.setLoading(true);\n                const response = await fetch('/api/metrics');\n                \n                if (!response.ok) {\n                    throw ErrorHandler.createNetworkError(\n                        `Failed to fetch metrics: HTTP ${response.status}`,\n                        { statusCode: response.status, url: '/api/metrics' }\n                    );\n                }\n                \n                const data = await response.json();\n                this.$store.metrics.update(data);\n                this.lastRefresh = new Date().toISOString();\n            } catch (error) {\n                const standardError = ErrorHandler.processError(\n                    error as Error,\n                    'metricsDashboard',\n                    'refresh_api_request'\n                );\n                ErrorHandler.showErrorToUser(standardError, 'metricsDashboard');\n                (this.$store.metrics as any).setError(standardError.message);\n            } finally {\n                this.$store.metrics.setLoading(false);\n            }\n        },\n        \n        formatUptime(seconds: number): string {\n            const hours = Math.floor(seconds / 3600);\n            const minutes = Math.floor((seconds % 3600) / 60);\n            const remainingSeconds = seconds % 60;\n            \n            if (hours > 0) {\n                return `${hours}h ${minutes}m`;\n            } else if (minutes > 0) {\n                return `${minutes}m ${remainingSeconds}s`;\n            } else {\n                return `${remainingSeconds}s`;\n            }\n        },\n        \n        formatMemoryUsage(bytes: number): string {\n            const units = ['B', 'KB', 'MB', 'GB'];\n            let value = bytes;\n            let unitIndex = 0;\n            \n            while (value >= 1024 && unitIndex < units.length - 1) {\n                value /= 1024;\n                unitIndex++;\n            }\n            \n            return `${value.toFixed(1)} ${units[unitIndex]}`;\n        },\n        \n        getStatusColor(status: string): string {\n            switch (status) {\n                case 'running':\n                    return 'text-green-400';\n                case 'error':\n                    return 'text-red-400';\n                case 'warning':\n                    return 'text-yellow-400';\n                default:\n                    return 'text-gray-400';\n            }\n        }\n    } as CustomAlpineComponent<MetricsDashboardData>;\n}\n\n// Removed default export - using named export only", "// Event Stream Alpine.js Component\n\nimport type * as Alpine from 'alpinejs';\nimport { EventData, SSEMessage, CustomAlpineComponent } from '../types/alpine';\nimport { ErrorHandler, ERROR_TYPES } from '../utils/error-handler';\n\n// Event Stream component data interface\ninterface EventStreamData {\n    events: EventData[];\n    initializeSSE(): void;\n    handleSSEMessage(event: SSEMessage): void;\n    handleEventStreamError(error: Error, method: string, args?: any[]): void;\n    sanitizeEventData(data: any): EventData;\n    sanitizeString(value: any): string;\n    getEventClass(type: string): string;\n    formatEvent(event: EventData): string;\n}\n\n/**\n * Event Stream Alpine.js Component\n * \n * This component manages server-sent events (SSE) for real-time event streaming.\n * It handles event reception, sanitization, and display with proper error handling.\n */\nexport function eventStream(): CustomAlpineComponent<EventStreamData> {\n    return {\n        /**\n         * Get all events from the event stream store\n         */\n        get events(): EventData[] {\n            return this.$store.eventStream.events;\n        },\n        \n        /**\n         * Initialize server-sent events (SSE)\n         * \n         * Note: SSE initialization is handled by HTMX\n         */\n        initializeSSE(): void {\n            // SSE initialization handled by HTMX\n        },\n        \n        /**\n         * Handle incoming SSE messages\n         */\n        handleSSEMessage(event: SSEMessage): void {\n            try {\n                const data = JSON.parse(event.detail.data);\n                // Sanitize event data before storing\n                const sanitizedData = this.sanitizeEventData(data);\n                this.$store.eventStream.addEvent(sanitizedData);\n            } catch (error) {\n                this.handleEventStreamError(error as Error, 'handleSSEMessage', [event]);\n            }\n        },\n        \n        /**\n         * Handle event stream errors with recovery mechanism\n         */\n        handleEventStreamError(error: Error, method: string, args: any[] = []): void {\n            // Use standardized error handler\n            const standardError = ErrorHandler.processError(\n                error,\n                'eventStream',\n                `${method}_event_stream_processing`\n            );\n            \n            // Show error to user through notification system\n            ErrorHandler.showErrorToUser(standardError, 'eventStream');\n            \n            // Add a fallback error event to the stream\n            try {\n                this.$store.eventStream.addEvent({\n                    type: 'error',\n                    message: 'Error processing event stream',\n                    timestamp: new Date().toISOString()\n                });\n            } catch (fallbackError) {\n                ErrorHandler.processError(\n                    fallbackError as Error,\n                    'eventStream',\n                    'fallbackErrorEvent'\n                );\n            }\n        },\n        \n        /**\n         * Sanitize event data to prevent XSS attacks\n         */\n        sanitizeEventData(data: any): EventData {\n            try {\n                const sanitized: Partial<EventData> = {};\n                \n                // Whitelist allowed properties and sanitize their values\n                const allowedProps: (keyof EventData)[] = ['type', 'name', 'message', 'uri', 'timestamp'];\n                \n                for (const prop of allowedProps) {\n                    if (data[prop] !== undefined) {\n                        sanitized[prop] = this.sanitizeString(data[prop]);\n                    }\n                }\n                \n                // Ensure timestamp is valid\n                if (sanitized.timestamp && !isNaN(Date.parse(sanitized.timestamp))) {\n                    sanitized.timestamp = new Date(sanitized.timestamp).toISOString();\n                } else {\n                    sanitized.timestamp = new Date().toISOString();\n                }\n                \n                // Ensure required fields are present\n                const result: EventData = {\n                    type: sanitized.type || 'unknown',\n                    timestamp: sanitized.timestamp,\n                    ...sanitized\n                };\n                \n                return result;\n            } catch (error) {\n                this.handleEventStreamError(error as Error, 'sanitizeEventData', [data]);\n                \n                // Return a safe fallback event\n                return {\n                    type: 'error',\n                    message: 'Failed to process event data',\n                    timestamp: new Date().toISOString()\n                };\n            }\n        },\n        \n        /**\n         * Sanitize a string value to prevent XSS\n         */\n        sanitizeString(value: any): string {\n            if (typeof value !== 'string') {\n                return String(value);\n            }\n            \n            // Limit length to prevent DoS\n            if (value.length > 500) {\n                value = value.substring(0, 500) + '...';\n            }\n            \n            // Escape HTML entities\n            const div = document.createElement('div');\n            div.textContent = value;\n            return div.innerHTML;\n        },\n        \n        /**\n         * Get CSS classes for an event based on its type\n         */\n        getEventClass(type: string): string {\n            const classes: Record<string, string> = {\n                'error': 'bg-red-900 bg-opacity-30 text-red-300 border-red-500',\n                'tool_called': 'bg-green-900 bg-opacity-30 text-green-300 border-green-500',\n                'default': 'bg-blue-900 bg-opacity-30 text-blue-300 border-blue-500'\n            };\n            return classes[type] || classes.default;\n        },\n        \n        /**\n         * Format an event object into a display string\n         */\n        formatEvent(event: EventData): string {\n            try {\n                const timestamp = new Date(event.timestamp).toLocaleTimeString();\n                let message = `[${timestamp}] ${event.type || 'unknown'}`;\n                \n                // All event properties are already sanitized at this point\n                if (event.name) message += `: ${event.name}`;\n                if (event.message) message += `: ${event.message}`;\n                if (event.uri) message += `: ${event.uri}`;\n                if (event.id) message += ` (${event.id})`;\n                \n                return message;\n            } catch (error) {\n                return '[Invalid event data]';\n            }\n        }\n    } as CustomAlpineComponent<EventStreamData>;\n}\n\n/**\n * Event stream store - using Alpine.js init event\n * \n * Global Alpine.js store for managing event stream data.\n * Provides methods to add events and manage the event history.\n */\nif (typeof document !== 'undefined') {\n    document.addEventListener('alpine:init', () => {\n    if (typeof window !== 'undefined' && window.Alpine) {\n        window.Alpine.store('eventStream', {\n            /** Array of event objects */\n            events: [] as EventData[],\n            \n            /** Maximum number of events to keep in memory */\n            maxEvents: 20,\n            \n            /**\n             * Add a new event to the stream\n             */\n            addEvent(event: EventData): void {\n                // Additional validation at store level\n                if (!event || typeof event !== 'object') {\n                    if (process.env.NODE_ENV === 'development') {\n                        console.warn('Invalid event data received');\n                    }\n                    return;\n                }\n                \n                const eventWithId: EventData = { \n                    ...event, \n                    id: (Date.now() + Math.random()).toString()\n                };\n                this.events.unshift(eventWithId);\n                \n                if (this.events.length > this.maxEvents) {\n                    this.events.pop();\n                }\n            },\n            \n            /**\n             * Clear all events from the stream\n             */\n            clear(): void {\n                this.events = [];\n            }\n        });\n    }\n    });\n}\n\n// Export component type for testing and module usage\nexport type EventStreamComponent = CustomAlpineComponent<EventStreamData>;", "// Notification System Alpine.js Component\n\nimport type * as Alpine from 'alpinejs';\nimport { ErrorHandler, ERROR_TYPES } from '../utils/error-handler';\nimport { NotificationItem, NotificationType, CustomAlpineComponent } from '../types/alpine';\n\n// Notification system component data interface\ninterface NotificationSystemData {\n    hasError: boolean;\n    errorMessage: string | null;\n    notifications: NotificationItem[];\n    _errorHandler: ((event: ErrorEvent) => void) | null;\n    \n    init(): void;\n    setupErrorHandling(): void;\n    remove(id: string | number): void;\n    getNotificationClass(type: NotificationType): string;\n    handleComponentError(error: Error, method: string, args?: any[]): void;\n    recoverFromError(): void;\n    destroy(): void;\n}\n\n/**\n * Notification System Alpine.js Component\n * \n * This component provides a notification display system with error handling\n * and recovery mechanisms. It integrates with the global notifications store\n * to display messages to users.\n */\nexport function notificationSystem(): CustomAlpineComponent<NotificationSystemData> {\n    return {\n        /** Whether the component has encountered an error */\n        hasError: false,\n        \n        /** Current error message */\n        errorMessage: null,\n        \n        /** Reference to the error event handler for cleanup */\n        _errorHandler: null as ((event: ErrorEvent) => void) | null,\n        \n        /**\n         * Initialize the notification system component\n         * Sets up error handling wrappers for critical methods\n         */\n        init(): void {\n            this.setupErrorHandling();\n        },\n        \n        /**\n         * Set up error handling wrappers for component methods\n         * \n         * Wraps critical methods with try-catch blocks to prevent\n         * component crashes and provide graceful error handling.\n         */\n        setupErrorHandling(): void {\n            // Wrap critical methods with error handling\n            const originalRemove = this.remove;\n            this.remove = (id: string | number) => {\n                try {\n                    return originalRemove.call(this, id);\n                } catch (error) {\n                    this.handleComponentError(error as Error, 'remove', [id]);\n                }\n            };\n            \n            // Set up global error handler\n            this._errorHandler = (event: ErrorEvent) => {\n                this.handleComponentError(event.error || new Error(event.message), 'globalError');\n            };\n            \n            window.addEventListener('error', this._errorHandler);\n        },\n        \n        /**\n         * Get all notifications from the store\n         */\n        get notifications(): NotificationItem[] {\n            try {\n                return this.$store.notifications?.items || [];\n            } catch (error) {\n                this.handleComponentError(error as Error, 'notifications getter');\n                return [];\n            }\n        },\n        \n        /**\n         * Remove a notification by ID\n         */\n        remove(id: string | number): void {\n            try {\n                this.$store.notifications.remove(id.toString());\n            } catch (error) {\n                this.handleComponentError(error as Error, 'remove', [id]);\n            }\n        },\n        \n        /**\n         * Get CSS classes for a notification based on its type\n         */\n        getNotificationClass(type: NotificationType): string {\n            try {\n                const classes: Record<NotificationType, string> = {\n                    'success': 'bg-green-900 text-green-300 border-green-700',\n                    'error': 'bg-red-900 text-red-300 border-red-700',\n                    'warning': 'bg-yellow-900 text-yellow-300 border-yellow-700',\n                    'info': 'bg-blue-900 text-blue-300 border-blue-700'\n                };\n                return classes[type] || classes.info;\n            } catch (error) {\n                this.handleComponentError(error as Error, 'getNotificationClass', [type]);\n                return 'bg-blue-900 text-blue-300 border-blue-700'; // fallback\n            }\n        },\n        \n        /**\n         * Handle component errors with recovery mechanism\n         */\n        handleComponentError(error: Error, method: string, args: any[] = []): void {\n            this.hasError = true;\n            this.errorMessage = error.message || 'Notification component error';\n            \n            // Use centralized error handling\n            const standardError = ErrorHandler.processError(\n                error,\n                'notificationSystem',\n                method\n            );\n            \n            // For notification system errors, don't show to user to avoid recursion\n            if (process.env.NODE_ENV === 'development') {\n                console.error('Notification System Error:', standardError.toJSON());\n            }\n            \n            // Attempt recovery after delay\n            setTimeout(() => {\n                this.recoverFromError();\n            }, 2000);\n        },\n        \n        /**\n         * Recover from component errors\n         * \n         * Resets error state and attempts to reinitialize the component.\n         */\n        recoverFromError(): void {\n            this.hasError = false;\n            this.errorMessage = null;\n            \n            // Reinitialize if needed\n            try {\n                this.setupErrorHandling();\n            } catch (error) {\n                if (process.env.NODE_ENV === 'development') {\n                    console.error('Failed to recover notification system:', error);\n                }\n            }\n        },\n\n        /**\n         * Destroy the notification system\n         */\n        destroy(): void {\n            // Cleanup any timers or observers\n            this.$store.notifications.clear();\n            \n            // Remove window event listeners\n            if (this._errorHandler) {\n                window.removeEventListener('error', this._errorHandler);\n                this._errorHandler = null;\n            }\n        }\n    } as CustomAlpineComponent<NotificationSystemData>;\n}\n\n/**\n * HTML escaping utility function\n * \n * Escapes HTML special characters to prevent XSS attacks\n */\nfunction escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n\n/**\n * Input sanitization function for notification messages\n * \n * Validates and sanitizes notification messages for security\n */\nfunction sanitizeMessage(message: any): string {\n    if (typeof message !== 'string') {\n        return 'Invalid message format';\n    }\n    \n    // Limit message length\n    if (message.length > 1000) {\n        message = message.substring(0, 1000) + '...';\n    }\n    \n    // Escape HTML and remove potentially dangerous content\n    return escapeHtml(message);\n}\n\n// Notification store interface\ninterface NotificationStore {\n    items: NotificationItem[];\n    add(message: string, type?: NotificationType, duration?: number): void;\n    remove(id: string | number): void;\n    clear(): void;\n}\n\n/**\n * Notifications store - using Alpine.js init event\n * \n * Global Alpine.js store for managing notification messages.\n * Provides methods to add, remove, and clear notifications.\n */\nif (typeof document !== 'undefined') {\n    document.addEventListener('alpine:init', () => {\n    if (typeof window !== 'undefined' && window.Alpine) {\n        window.Alpine.store('notifications', {\n            /** Array of active notification objects */\n            items: [] as NotificationItem[],\n            \n            /**\n             * Add a new notification to the store\n             */\n            add(message: string, type: NotificationType = 'info', duration: number = 5000): void {\n                try {\n                    // Sanitize input parameters\n                    const sanitizedMessage = sanitizeMessage(message);\n                    const validTypes: NotificationType[] = ['success', 'error', 'warning', 'info'];\n                    const sanitizedType = validTypes.includes(type) ? type : 'info';\n                    const sanitizedDuration = Math.max(0, Math.min(duration, 30000)); // 0-30s limit\n                    \n                    const notification: NotificationItem = {\n                        id: (Date.now() + Math.random()).toString(),\n                        message: sanitizedMessage,\n                        type: sanitizedType,\n                        timestamp: Date.now(),\n                        duration: sanitizedDuration\n                    };\n                    \n                    this.items.push(notification);\n                    \n                    if (sanitizedDuration > 0) {\n                        setTimeout(() => {\n                            this.remove(notification.id);\n                        }, sanitizedDuration);\n                    }\n                } catch (error) {\n                    if (process.env.NODE_ENV === 'development') {\n                        console.error('Error adding notification:', error);\n                    }\n                    \n                    // Fallback: add a basic error notification\n                    this.items.push({\n                        id: (Date.now() + Math.random()).toString(),\n                        message: 'Error processing notification',\n                        type: 'error',\n                        timestamp: Date.now(),\n                        duration: 5000\n                    });\n                }\n            },\n            \n            /**\n             * Remove a notification by ID\n             */\n            remove(id: string | number): void {\n                this.items = this.items.filter(item => item.id !== id);\n            },\n            \n            /**\n             * Clear all notifications\n             */\n            clear(): void {\n                this.items = [];\n            },\n            \n            /**\n             * Get notifications by type\n             */\n            getByType(type: NotificationType): NotificationItem[] {\n                return this.items.filter((item: NotificationItem) => item.type === type);\n            },\n            \n            /**\n             * Get notification count\n             */\n            getCount(): number {\n                return this.items.length;\n            },\n            \n            /**\n             * Get notification count by type\n             */\n            getCountByType(type: NotificationType): number {\n                return this.items.filter((item: NotificationItem) => item.type === type).length;\n            }\n        } as NotificationStore);\n    }\n    });\n}\n\n// Export type for testing and module usage\nexport type NotificationSystemComponent = CustomAlpineComponent<NotificationSystemData>;", "// Enhanced Tool Executor Component\n\nimport type * as Alpine from 'alpinejs';\nimport { ToolParameter, ToolResult, CustomAlpineComponent } from '../types/alpine';\nimport { ErrorHandler, ERROR_TYPES } from '../utils/error-handler';\n\n// Tool execution result interface\ninterface ToolExecutionResult {\n    id: string;\n    success: boolean;\n    result?: any;\n    error?: string;\n    duration: number;\n    timestamp: string;\n    args: Record<string, any>;\n}\n\n// Tool statistics interface\ninterface ToolStats {\n    executions: number;\n    successRate: number;\n    averageTime: number;\n    lastResult: ToolExecutionResult | null;\n}\n\n// Tool executor component data interface\ninterface ToolExecutorData {\n    toolName: string;\n    loading: boolean;\n    lastResult: ToolExecutionResult | null;\n    executionHistory: ToolExecutionResult[];\n    \n    execute(args?: Record<string, any>): Promise<any>;\n    getSuccessRate(): number;\n    getAverageExecutionTime(): number;\n    clearHistory(): void;\n}\n\n// API response interface\ninterface ToolExecutionResponse {\n    success: boolean;\n    result?: any;\n    error?: string;\n}\n\nexport function toolExecutor(toolName: string): CustomAlpineComponent<ToolExecutorData> {\n    return {\n        toolName,\n        loading: false,\n        lastResult: null,\n        executionHistory: [],\n        \n        async execute(args: Record<string, any> = {}): Promise<ToolExecutionResponse> {\n            (this as any).loading = true;\n            const executionId = (Date.now() + Math.random()).toString();\n            const startTime = Date.now();\n            \n            try {\n                const response = await fetch('/api/tools/execute', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({\n                        name: (this as any).toolName,\n                        arguments: args\n                    })\n                });\n                \n                const data: ToolExecutionResponse = await response.json();\n                const endTime = Date.now();\n                const duration = endTime - startTime;\n                \n                // Store execution result\n                (this as any).lastResult = {\n                    id: executionId,\n                    success: data.success,\n                    result: data.result,\n                    error: data.error,\n                    duration,\n                    timestamp: new Date().toISOString(),\n                    args\n                };\n                \n                // Add to history\n                (this as any).executionHistory.unshift((this as any).lastResult);\n                if ((this as any).executionHistory.length > 10) {\n                    (this as any).executionHistory.pop();\n                }\n                \n                if (data.success) {\n                    (this as any).$store.notifications.add(\n                        `Tool \"${(this as any).toolName}\" executed successfully (${duration}ms)`,\n                        'success'\n                    );\n                    \n                    // Trigger HTMX updates\n                    (this as any).$store.dashboard.refreshAll();\n                } else {\n                    (this as any).$store.notifications.add(\n                        `Tool execution failed: ${data.error}`,\n                        'error'\n                    );\n                }\n                \n                return data;\n                \n            } catch (error) {\n                // Use standardized error handler\n                const standardError = ErrorHandler.processError(\n                    error as Error,\n                    'toolExecutor',\n                    `execute_${(this as any).toolName}`\n                );\n                \n                const errorResult: ToolExecutionResult = {\n                    id: executionId,\n                    success: false,\n                    error: standardError.message,\n                    duration: Date.now() - startTime,\n                    timestamp: new Date().toISOString(),\n                    args\n                };\n                \n                (this as any).lastResult = errorResult;\n                (this as any).executionHistory.unshift(errorResult);\n                \n                // Show standardized error to user\n                ErrorHandler.showErrorToUser(standardError, 'toolExecutor');\n                \n                throw standardError;\n            } finally {\n                (this as any).loading = false;\n            }\n        },\n        \n        getSuccessRate(): number {\n            if ((this as any).executionHistory.length === 0) return 0;\n            const successful = (this as any).executionHistory.filter((h: any) => h.success).length;\n            return Math.round((successful / (this as any).executionHistory.length) * 100);\n        },\n        \n        getAverageExecutionTime(): number {\n            if ((this as any).executionHistory.length === 0) return 0;\n            const total = (this as any).executionHistory.reduce((sum: number, h: any) => sum + h.duration, 0);\n            return Math.round(total / (this as any).executionHistory.length);\n        },\n        \n        clearHistory(): void {\n            (this as any).executionHistory = [];\n            (this as any).lastResult = null;\n        }\n    } as unknown as CustomAlpineComponent<ToolExecutorData>;\n}\n\n// Tool execution store interface\nexport interface ToolExecutionStore {\n    activeExecutions: Map<string, CustomAlpineComponent<ToolExecutorData>>;\n    getExecutor(toolName: string): CustomAlpineComponent<ToolExecutorData>;\n    executeGlobal(toolName: string, args?: Record<string, any>): Promise<ToolExecutionResponse>;\n    getToolStats(toolName: string): ToolStats | null;\n    getAllStats(): Record<string, ToolStats>;\n}\n\n// Global tool execution helper\nif (typeof window !== 'undefined') {\n    window.addEventListener('alpine:init', () => {\n        if (window.Alpine) {\n            window.Alpine.store('toolExecution', {\n                activeExecutions: new Map<string, ToolExecutorComponent>(),\n                \n                getExecutor(toolName: string): ToolExecutorComponent {\n                    if (!this.activeExecutions.has(toolName)) {\n                        this.activeExecutions.set(toolName, toolExecutor(toolName));\n                    }\n                    return this.activeExecutions.get(toolName)!;\n                },\n                \n                async executeGlobal(toolName: string, args: Record<string, any> = {}): Promise<ToolExecutionResponse> {\n                    const executor = this.getExecutor(toolName);\n                    return await executor.execute(args);\n                },\n                \n                getToolStats(toolName: string): ToolStats | null {\n                    const executor = this.activeExecutions.get(toolName);\n                    if (!executor) return null;\n                    \n                    return {\n                        executions: executor.executionHistory.length,\n                        successRate: executor.getSuccessRate(),\n                        averageTime: executor.getAverageExecutionTime(),\n                        lastResult: executor.lastResult\n                    };\n                },\n                \n                getAllStats(): Record<string, ToolStats> {\n                    const stats: Record<string, ToolStats> = {};\n                    this.activeExecutions.forEach((executor, toolName) => {\n                        const toolStats = this.getToolStats(toolName);\n                        if (toolStats) {\n                            stats[toolName] = toolStats;\n                        }\n                    });\n                    return stats;\n                },\n                \n                /**\n                 * Clear all execution history\n                 */\n                clearAllHistory(): void {\n                    this.activeExecutions.forEach(executor => {\n                        executor.clearHistory();\n                    });\n                },\n                \n                /**\n                 * Get total execution count across all tools\n                 */\n                getTotalExecutions(): number {\n                    let total = 0;\n                    this.activeExecutions.forEach(executor => {\n                        total += executor.executionHistory.length;\n                    });\n                    return total;\n                },\n                \n                /**\n                 * Get overall success rate across all tools\n                 */\n                getOverallSuccessRate(): number {\n                    let totalExecutions = 0;\n                    let successfulExecutions = 0;\n                    \n                    this.activeExecutions.forEach(executor => {\n                        totalExecutions += executor.executionHistory.length;\n                        successfulExecutions += executor.executionHistory.filter(h => h.success).length;\n                    });\n                    \n                    return totalExecutions > 0 ? Math.round((successfulExecutions / totalExecutions) * 100) : 0;\n                }\n            } as ToolExecutionStore);\n        }\n    });\n}\n\n// Export type for testing and module usage\nexport type ToolExecutorComponent = CustomAlpineComponent<ToolExecutorData>;", "// HTMX-Alpine.js Bridge Component\n// TypeScript version with proper type definitions\n\nimport type { DashboardStore, StatusStore, ToolCallsStore } from './htmx-alpine-bridge.d';\n\n// Enhanced HTMX event type definitions\ninterface HTMXEventDetail {\n    target: HTMLElement;\n    xhr: XMLHttpRequest;\n    data?: string;\n    requestConfig?: any;\n}\n\ninterface HTMXEvent extends CustomEvent<HTMXEventDetail> {\n    detail: HTMXEventDetail;\n}\n\n// Enhanced store type definitions\ninterface MetricsStore {\n    data: Record<string, any>;\n    loading: boolean;\n    update(newData: Record<string, any>): void;\n    setLoading(state: boolean): void;\n}\n\ninterface NotificationStore {\n    add(message: string, type: 'error' | 'success' | 'warning' | 'info'): void;\n}\n\ninterface EventStreamStore {\n    addEvent(data: any): void;\n}\n\n// Type-safe store access\nfunction getStore<T>(name: string): T {\n    return window.Alpine.store(name) as T;\n}\n\nexport function initializeHtmxAlpineBridge(): void {\n    // HTMX to Alpine.js event bridge\n    document.body.addEventListener('htmx:afterSwap', function(event: Event) {\n        const htmxEvent = event as HTMXEvent;\n        const target = htmxEvent.detail.target;\n        \n        // Update metrics store when metrics endpoint responds\n        if (target.id === 'metrics-data') {\n            try {\n                const data = JSON.parse(htmxEvent.detail.xhr.response);\n                getStore<MetricsStore>('metrics').update(data);\n            } catch (error) {\n                console.error('Error parsing metrics data:', error);\n                getStore<NotificationStore>('notifications').add('Error updating metrics', 'error');\n            }\n        }\n        \n        // Handle status updates\n        if (target.id === 'status-data') {\n            try {\n                const data = JSON.parse(htmxEvent.detail.xhr.response);\n                getStore<StatusStore>('status').update(data);\n            } catch (error) {\n                console.error('Error parsing status data:', error);\n            }\n        }\n        \n        // Handle tool calls updates\n        if (target.id === 'tool-calls-data') {\n            try {\n                const data = JSON.parse(htmxEvent.detail.xhr.response);\n                getStore<ToolCallsStore>('toolCalls').update(data);\n            } catch (error) {\n                console.error('Error parsing tool calls data:', error);\n            }\n        }\n    });\n    \n    // HTMX request interceptor for Alpine.js integration\n    document.body.addEventListener('htmx:beforeRequest', function(event: Event) {\n        const htmxEvent = event as HTMXEvent;\n        const target = htmxEvent.detail.target;\n        \n        // Set loading states for relevant stores\n        if (target.id === 'metrics-data') {\n            getStore<MetricsStore>('metrics').setLoading(true);\n        }\n        \n        if (target.id === 'status-data') {\n            getStore<StatusStore>('status').setLoading(true);\n        }\n    });\n    \n    // HTMX error handling\n    document.body.addEventListener('htmx:responseError', function(event: Event) {\n        const htmxEvent = event as HTMXEvent;\n        const status = htmxEvent.detail.xhr.status;\n        const target = htmxEvent.detail.target;\n        \n        let message = `Request failed (${status})`;\n        if (target.id === 'metrics-data') {\n            message = 'Failed to load metrics';\n            getStore<MetricsStore>('metrics').setLoading(false);\n        } else if (target.id === 'status-data') {\n            message = 'Failed to load server status';\n            getStore<StatusStore>('status').setLoading(false);\n        }\n        \n        getStore<NotificationStore>('notifications').add(message, 'error');\n    });\n    \n    // HTMX SSE integration with Alpine.js\n    document.body.addEventListener('htmx:sseMessage', function(event: Event) {\n        const htmxEvent = event as HTMXEvent;\n        try {\n            const data = JSON.parse(htmxEvent.detail.data || '{}');\n            getStore<EventStreamStore>('eventStream').addEvent(data);\n        } catch (error) {\n            console.error('Error parsing SSE message:', error);\n        }\n    });\n    \n    // SSE connection status integration\n    document.body.addEventListener('htmx:sseOpen', function(event: Event) {\n        getStore<NotificationStore>('notifications').add('Live events connected', 'success');\n        getStore<DashboardStore>('dashboard').setSSEConnected(true);\n    });\n    \n    document.body.addEventListener('htmx:sseError', function(event: Event) {\n        getStore<NotificationStore>('notifications').add('Live events connection error', 'error');\n        getStore<DashboardStore>('dashboard').setSSEConnected(false);\n    });\n    \n    document.body.addEventListener('htmx:sseClose', function(event: Event) {\n        getStore<NotificationStore>('notifications').add('Live events disconnected', 'warning');\n        getStore<DashboardStore>('dashboard').setSSEConnected(false);\n    });\n}\n\n// Type-safe store implementations\ninterface DashboardStoreImpl extends DashboardStore {\n    sseConnected: boolean;\n    lastUpdate: string | null;\n    \n    setSSEConnected(connected: boolean): void;\n    triggerUpdate(endpoint: string): void;\n    refreshAll(): void;\n}\n\ninterface StatusStoreImpl extends StatusStore {\n    data: Record<string, any>;\n    loading: boolean;\n    \n    update(newData: Record<string, any>): void;\n    setLoading(state: boolean): void;\n}\n\ninterface ToolCallsStoreImpl extends ToolCallsStore {\n    data: any[];\n    loading: boolean;\n    \n    update(newData: any[]): void;\n    setLoading(state: boolean): void;\n}\n\n// Dashboard store for cross-component communication\ndocument.addEventListener('alpine:init', () => {\n    const dashboardStore: DashboardStoreImpl = {\n        sseConnected: false,\n        lastUpdate: null,\n        \n        setSSEConnected(connected: boolean): void {\n            this.sseConnected = connected;\n        },\n        \n        triggerUpdate(endpoint: string): void {\n            // Type-safe HTMX access\n            if (typeof window !== 'undefined' && (window as any).htmx) {\n                (window as any).htmx.trigger(`#${endpoint}-data`, 'htmx:trigger');\n                this.lastUpdate = new Date().toISOString();\n            }\n        },\n        \n        refreshAll(): void {\n            this.triggerUpdate('metrics');\n            this.triggerUpdate('status');\n            this.triggerUpdate('tool-calls');\n        }\n    };\n    \n    window.Alpine.store('dashboard', dashboardStore);\n    \n    // Enhanced status store\n    const statusStore: StatusStoreImpl = {\n        data: {},\n        loading: false,\n        \n        update(newData: Record<string, any>): void {\n            this.data = { ...this.data, ...newData };\n            this.loading = false;\n        },\n        \n        setLoading(state: boolean): void {\n            this.loading = state;\n        }\n    };\n    \n    window.Alpine.store('status', statusStore);\n    \n    // Enhanced tool calls store\n    const toolCallsStore: ToolCallsStoreImpl = {\n        data: [],\n        loading: false,\n        \n        update(newData: any[]): void {\n            this.data = Array.isArray(newData) ? newData : [];\n            this.loading = false;\n        },\n        \n        setLoading(state: boolean): void {\n            this.loading = state;\n        }\n    };\n    \n    window.Alpine.store('toolCalls', toolCallsStore);\n});", "// Dashboard Controls Component for bi-directional communication\n\nimport type * as Alpine from 'alpinejs';\nimport { EventData, DashboardState, CustomAlpineComponent } from '../types/alpine';\nimport { eventStream } from './event-stream';\nimport { ErrorHandler, ERROR_TYPES } from '../utils/error-handler';\n\n// Dashboard export data interface\ninterface DashboardExportData {\n    metrics: any;\n    events: EventData[];\n    toolStats: any;\n    timestamp: string;\n}\n\n// Dashboard controls component data interface\ninterface DashboardControlsData {\n    refreshing: boolean;\n    autoRefresh: boolean;\n    refreshInterval: number;\n    intervalId: NodeJS.Timeout | null;\n    \n    init(): void;\n    refreshAll(): Promise<void>;\n    toggleAutoRefresh(): void;\n    startAutoRefresh(): void;\n    stopAutoRefresh(): void;\n    setRefreshInterval(interval: number): void;\n    clearAllData(): Promise<void>;\n    exportData(): void;\n    connectionStatus: string;\n    lastUpdate: string;\n}\n\nexport function dashboardControls(): CustomAlpineComponent<DashboardControlsData> {\n    return {\n        refreshing: false,\n        autoRefresh: true,\n        refreshInterval: 2000,\n        intervalId: null,\n        \n        init(): void {\n            this.startAutoRefresh();\n        },\n        \n        async refreshAll(): Promise<void> {\n            this.refreshing = true;\n            try {\n                const dashboardStore = this.$store.dashboard;\n                dashboardStore.refreshAll();\n                this.$store.notifications.add('Dashboard refreshed', 'success');\n            } catch (error) {\n                const standardError = ErrorHandler.processError(\n                    error as Error,\n                    'dashboardControls',\n                    'refreshAll_manual_refresh'\n                );\n                ErrorHandler.showErrorToUser(standardError, 'dashboardControls');\n            } finally {\n                this.refreshing = false;\n            }\n        },\n        \n        toggleAutoRefresh(): void {\n            this.autoRefresh = !this.autoRefresh;\n            if (this.autoRefresh) {\n                this.startAutoRefresh();\n                this.$store.notifications.add('Auto-refresh enabled', 'info');\n            } else {\n                this.stopAutoRefresh();\n                this.$store.notifications.add('Auto-refresh disabled', 'info');\n            }\n        },\n        \n        startAutoRefresh(): void {\n            if (this.intervalId) {\n                clearInterval(this.intervalId);\n            }\n            \n            if (this.autoRefresh) {\n                this.intervalId = setInterval(() => {\n                    if (!this.refreshing) {\n                        this.$store.dashboard.refreshAll();\n                    }\n                }, this.refreshInterval);\n            }\n        },\n        \n        stopAutoRefresh(): void {\n            if (this.intervalId) {\n                clearInterval(this.intervalId);\n                this.intervalId = null;\n            }\n        },\n        \n        setRefreshInterval(interval: number): void {\n            this.refreshInterval = interval;\n            if (this.autoRefresh) {\n                this.startAutoRefresh();\n            }\n        },\n        \n        async clearAllData(): Promise<void> {\n            try {\n                // Clear all Alpine.js stores\n                this.$store.metrics.data = {\n                    total_tool_calls: 0,\n                    success_rate: 0,\n                    active_sessions: 0,\n                    avg_duration_ms: 0,\n                    tools_available: 0,\n                    resources_available: 0\n                };\n                this.$store.eventStream.clear();\n                this.$store.notifications.clear();\n                \n                // Clear tool execution history\n                const toolExecutionStore = this.$store.toolExecution;\n                if (toolExecutionStore && toolExecutionStore.activeExecutions) {\n                    toolExecutionStore.activeExecutions.forEach((executor: any) => {\n                        if (executor.clearHistory) {\n                            executor.clearHistory();\n                        }\n                    });\n                }\n                \n                this.$store.notifications.add('All data cleared', 'success');\n            } catch (error) {\n                const standardError = ErrorHandler.processError(\n                    error as Error,\n                    'dashboardControls',\n                    'clearAllData_data_clear'\n                );\n                ErrorHandler.showErrorToUser(standardError, 'dashboardControls');\n            }\n        },\n        \n        exportData(): void {\n            try {\n                const data: DashboardExportData = {\n                    metrics: this.$store.metrics.data,\n                    events: this.$store.eventStream.events,\n                    toolStats: this.$store.toolExecution?.getAllStats ? this.$store.toolExecution.getAllStats() : {},\n                    timestamp: new Date().toISOString()\n                };\n                \n                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n                const url = URL.createObjectURL(blob);\n                const a = document.createElement('a');\n                a.href = url;\n                a.download = `mcp-dashboard-export-${new Date().toISOString().split('T')[0]}.json`;\n                a.click();\n                URL.revokeObjectURL(url);\n                \n                this.$store.notifications.add('Data exported successfully', 'success');\n            } catch (error) {\n                const standardError = ErrorHandler.processError(\n                    error as Error,\n                    'dashboardControls',\n                    'exportData_data_export'\n                );\n                ErrorHandler.showErrorToUser(standardError, 'dashboardControls');\n            }\n        },\n        \n        get connectionStatus(): string {\n            return this.$store.dashboard.sseConnected ? 'connected' : 'disconnected';\n        },\n        \n        get lastUpdate(): string {\n            return this.$store.dashboard.lastUpdate;\n        }\n    } as CustomAlpineComponent<DashboardControlsData>;\n}\n\n// Enhanced event stream component data interface\ninterface EnhancedEventStreamData {\n    pauseStream: boolean;\n    maxEvents: number;\n    events: EventData[];\n    \n    togglePause(): void;\n    handleSSEMessage(event: { detail: { data: string } }): void;\n    filterEvents(type: string): EventData[];\n    clearEvents(): void;\n    \n    // Methods from eventStream\n    initializeSSE(): void;\n    sanitizeEventData(data: any): EventData;\n    sanitizeString(value: any): string;\n    getEventClass(type: string): string;\n    formatEvent(event: EventData): string;\n    handleEventStreamError(error: Error, method: string, args?: any[]): void;\n}\n\n// Enhanced event stream component with bi-directional communication\nexport function enhancedEventStream(): CustomAlpineComponent<EnhancedEventStreamData> {\n    const baseEventStream = eventStream();\n    \n    return {\n        ...baseEventStream,\n        \n        pauseStream: false,\n        maxEvents: 50,\n        \n        togglePause(): void {\n            this.pauseStream = !this.pauseStream;\n            if (this.pauseStream) {\n                this.$store.notifications.add('Event stream paused', 'info');\n            } else {\n                this.$store.notifications.add('Event stream resumed', 'info');\n            }\n        },\n        \n        handleSSEMessage(event: { detail: { data: string } }): void {\n            if (this.pauseStream) return;\n            \n            try {\n                const data = JSON.parse(event.detail.data);\n                this.$store.eventStream.addEvent(data);\n                \n                // Trigger related updates based on event type\n                if (data.type === 'tool_called') {\n                    const dashboardStore = this.$store.dashboard;\n                    if (dashboardStore.triggerUpdate) {\n                        dashboardStore.triggerUpdate('metrics');\n                        dashboardStore.triggerUpdate('tool-calls');\n                    }\n                }\n            } catch (error) {\n                ErrorHandler.processError(\n                    error as Error,\n                    'dashboardControls',\n                    'initSSE_sse_message_parsing'\n                );\n            }\n        },\n        \n        filterEvents(type: string): EventData[] {\n            return this.$store.eventStream.events.filter((event: EventData) => \n                type === 'all' || event.type === type\n            );\n        },\n        \n        clearEvents(): void {\n            this.$store.eventStream.clear();\n            this.$store.notifications.add('Events cleared', 'info');\n        }\n    } as CustomAlpineComponent<EnhancedEventStreamData>;\n}\n\n// Export types for testing and module usage\nexport type DashboardControlsComponent = CustomAlpineComponent<DashboardControlsData>;\nexport type EnhancedEventStreamComponent = CustomAlpineComponent<EnhancedEventStreamData>;", "/**\n * Alpine.js Components Entry Point\n * \n * This module serves as the main entry point for all Alpine.js components\n * used in the MCP Server Dashboard. It handles component registration,\n * sets up error handling, and initializes the Alpine.js framework.\n */\n\n/**\n * @fileoverview Main Alpine.js components initialization and registration\n * @module alpine-components\n */\n\nimport { ErrorHandler, setupGlobalErrorHandling } from './utils/error-handler';\n\n// Import Alpine.js components\nimport { echoTool } from './components/echo-tool';\nimport { metricsStore } from './components/metrics-dashboard';\nimport { eventStream } from './components/event-stream';\nimport { notificationSystem } from './components/notification-system';\nimport { toolExecutor } from './components/tool-executor';\nimport { initializeHtmxAlpineBridge } from './components/htmx-alpine-bridge';\nimport { dashboardControls, enhancedEventStream } from './components/dashboard-controls';\n\n// Import component types\nimport type { EchoToolComponent } from './components/echo-tool';\nimport type { MetricsStoreComponent } from './components/metrics-dashboard';\nimport type { EventStreamComponent } from './components/event-stream';\nimport type { NotificationSystemComponent } from './components/notification-system';\nimport type { ToolExecutorComponent } from './components/tool-executor';\nimport type { DashboardControlsComponent, EnhancedEventStreamComponent } from './components/dashboard-controls';\n\n/**\n * Setup global error handling for the application.\n * This catches unhandled errors and promise rejections\n * to provide a better user experience.\n */\nsetupGlobalErrorHandling();\n\n/**\n * Makes all Alpine.js components available globally on the window object\n * for easy access from HTML templates.\n */\nwindow.echoTool = echoTool;\nwindow.metricsStore = metricsStore;\nwindow.eventStream = eventStream;\nwindow.notificationSystem = notificationSystem;\nwindow.toolExecutor = (toolName?: string) => toolExecutor(toolName || 'default');\nwindow.dashboardControls = dashboardControls;\nwindow.enhancedEventStream = enhancedEventStream;\n\n/**\n * Initialize Alpine.js framework\n * \n * Starts the Alpine.js framework and activates all registered components.\n * This should be called after all components are registered.\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n    try {\n        if (window.Alpine) {\n            window.Alpine.start();\n            console.log('Alpine.js initialized successfully');\n        } else {\n            throw new Error('Alpine.js not found. Please include Alpine.js before this script.');\n        }\n    } catch (error) {\n        ErrorHandler.processError(error, 'AlpineInit', 'initialization');\n    }\n});\n\n/**\n * Initialize HTMX-Alpine.js bridge after Alpine is ready\n * \n * Sets up the integration between HTMX and Alpine.js for\n * dynamic content loading with proper Alpine component initialization.\n */\ndocument.addEventListener('alpine:init', () => {\n    try {\n        initializeHtmxAlpineBridge();\n        console.log('HTMX-Alpine bridge initialized');\n    } catch (error) {\n        ErrorHandler.processError(error, 'HTMXAlpineBridge', 'initialization');\n    }\n});\n\n// Export for testing purposes\nexport {\n    echoTool,\n    metricsStore,\n    eventStream,\n    notificationSystem,\n    toolExecutor,\n    dashboardControls,\n    enhancedEventStream\n};"],
  "mappings": "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",
  "names": []
}
