// MCP Dashboard Alpine.js Bundle - Built 2025-07-18T04:01:40.177Z
"use strict";
(() => {
  // static/js/utils/error-handler.ts
  var ERROR_TYPES = {
    VALIDATION: "validation",
    NETWORK: "network",
    SECURITY: "security",
    SYSTEM: "system",
    USER: "user",
    UNKNOWN: "unknown"
  };
  var ERROR_SEVERITY = {
    LOW: "low",
    MEDIUM: "medium",
    HIGH: "high",
    CRITICAL: "critical"
  };
  function isValidationError(error) {
    const validationKeywords = [
      "validation",
      "invalid",
      "required",
      "missing",
      "empty",
      "null",
      "undefined",
      "format",
      "syntax",
      "parse",
      "malformed",
      "expected",
      "must be",
      "cannot be",
      "too short",
      "too long",
      "out of range",
      "not allowed",
      "schema",
      "type error"
    ];
    const message = error.message.toLowerCase();
    const name = error.name.toLowerCase();
    return validationKeywords.some(
      (keyword) => message.includes(keyword) || name.includes(keyword)
    ) || error.name === "TypeError" || error.name === "SyntaxError";
  }
  function isNetworkError(error) {
    const networkKeywords = [
      "network",
      "fetch",
      "request",
      "response",
      "connection",
      "timeout",
      "abort",
      "offline",
      "cors",
      "http",
      "ssl",
      "tls",
      "dns",
      "socket",
      "refused",
      "unreachable",
      "gateway",
      "proxy",
      "status 4",
      "status 5"
    ];
    const message = error.message.toLowerCase();
    const name = error.name.toLowerCase();
    return networkKeywords.some(
      (keyword) => message.includes(keyword) || name.includes(keyword)
    ) || /failed to fetch|network error|load failed/i.test(error.message);
  }
  function isSecurityError(error) {
    const securityKeywords = [
      "security",
      "permission",
      "unauthorized",
      "forbidden",
      "access denied",
      "authentication",
      "authorization",
      "token",
      "csrf",
      "xss",
      "injection",
      "blocked",
      "restricted",
      "credentials",
      "login",
      "session expired"
    ];
    const message = error.message.toLowerCase();
    const name = error.name.toLowerCase();
    return securityKeywords.some(
      (keyword) => message.includes(keyword) || name.includes(keyword)
    ) || /status 40[13]/i.test(error.message);
  }
  function isSystemError(error) {
    const systemKeywords = [
      "memory",
      "disk",
      "file system",
      "database",
      "server",
      "internal",
      "crash",
      "overflow",
      "stack",
      "heap",
      "resource",
      "quota",
      "limit",
      "unavailable",
      "maintenance",
      "overload",
      "capacity"
    ];
    const message = error.message.toLowerCase();
    const name = error.name.toLowerCase();
    return systemKeywords.some(
      (keyword) => message.includes(keyword) || name.includes(keyword)
    ) || /status 50\d/i.test(error.message) || // 5xx status codes
    error.name === "RangeError" || error.name === "ReferenceError";
  }
  function isUserError(error) {
    const userKeywords = [
      "user",
      "input",
      "action",
      "operation",
      "cancelled",
      "aborted",
      "interrupted",
      "duplicate",
      "already exists",
      "not found",
      "empty result"
    ];
    const message = error.message.toLowerCase();
    const name = error.name.toLowerCase();
    return userKeywords.some(
      (keyword) => message.includes(keyword) || name.includes(keyword)
    ) || /status 404|status 409|status 410/i.test(error.message);
  }
  var StandardError = class extends Error {
    constructor(message, type = ERROR_TYPES.UNKNOWN, severity = ERROR_SEVERITY.MEDIUM, details = {}) {
      super(message);
      this.name = "StandardError";
      this.type = type;
      this.severity = severity;
      this.details = details;
      this.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      this.userMessage = this.getUserFriendlyMessage();
    }
    /**
     * Get user-friendly error message
     */
    getUserFriendlyMessage() {
      const friendlyMessages = {
        [ERROR_TYPES.VALIDATION]: "Please check your input and try again.",
        [ERROR_TYPES.NETWORK]: "Network connection issue. Please try again.",
        [ERROR_TYPES.SECURITY]: "Security error. Please contact support.",
        [ERROR_TYPES.SYSTEM]: "System error. Please try again later.",
        [ERROR_TYPES.USER]: this.message,
        [ERROR_TYPES.UNKNOWN]: "An unexpected error occurred. Please try again."
      };
      return friendlyMessages[this.type] || friendlyMessages[ERROR_TYPES.UNKNOWN];
    }
    /**
     * Convert error to JSON format
     */
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        type: this.type,
        severity: this.severity,
        details: this.details,
        timestamp: this.timestamp,
        userMessage: this.userMessage
      };
    }
  };
  var ErrorHandler = class {
    /**
     * Sanitize stack traces for production environments
     */
    static sanitizeStackTrace(stack) {
      if (!stack)
        return void 0;
      if (false) {
        return stack.split("\n").map((line) => {
          if (!line.trim().startsWith("at ")) {
            return line;
          }
          const match = line.match(/at\s+([^(]+)/);
          if (match) {
            return `    at ${match[1].trim()}`;
          }
          return "    at <sanitized>";
        }).slice(0, 5).join("\n");
      }
      return stack;
    }
    /**
     * Create validation error
     */
    static createValidationError(message, details = {}) {
      return new StandardError(message, ERROR_TYPES.VALIDATION, ERROR_SEVERITY.LOW, details);
    }
    /**
     * Create network error
     */
    static createNetworkError(message, details = {}) {
      return new StandardError(message, ERROR_TYPES.NETWORK, ERROR_SEVERITY.MEDIUM, details);
    }
    /**
     * Create security error
     */
    static createSecurityError(message, details = {}) {
      return new StandardError(message, ERROR_TYPES.SECURITY, ERROR_SEVERITY.HIGH, details);
    }
    /**
     * Create system error
     */
    static createSystemError(message, details = {}) {
      return new StandardError(message, ERROR_TYPES.SYSTEM, ERROR_SEVERITY.MEDIUM, details);
    }
    /**
     * Create user error
     */
    static createUserError(message, details = {}) {
      return new StandardError(message, ERROR_TYPES.USER, ERROR_SEVERITY.LOW, details);
    }
    /**
     * Get error category and suggestions based on error type
     */
    static getErrorAnalysis(error) {
      const analysisMap = {
        [ERROR_TYPES.VALIDATION]: {
          category: "Input Validation",
          suggestions: [
            "Check that all required fields are filled",
            "Verify data format matches expected pattern",
            "Ensure values are within acceptable ranges"
          ],
          isRecoverable: true,
          userAction: "Please correct your input and try again"
        },
        [ERROR_TYPES.NETWORK]: {
          category: "Network/Connectivity",
          suggestions: [
            "Check your internet connection",
            "Try refreshing the page",
            "Check if the server is accessible",
            "Verify proxy/firewall settings"
          ],
          isRecoverable: true,
          userAction: "Please check your connection and retry"
        },
        [ERROR_TYPES.SECURITY]: {
          category: "Security/Authentication",
          suggestions: [
            "Verify your login credentials",
            "Check if your session has expired",
            "Ensure you have proper permissions",
            "Contact administrator if needed"
          ],
          isRecoverable: false,
          userAction: "Authentication required - please log in again"
        },
        [ERROR_TYPES.SYSTEM]: {
          category: "System/Server",
          suggestions: [
            "Wait a moment and try again",
            "Check system status page",
            "Contact technical support",
            "Save your work and restart the application"
          ],
          isRecoverable: false,
          userAction: "System issue detected - please try again later"
        },
        [ERROR_TYPES.USER]: {
          category: "User Operation",
          suggestions: [
            "Review the requested operation",
            "Check if the resource exists",
            "Verify you have the right permissions",
            "Try a different approach"
          ],
          isRecoverable: true,
          userAction: "Please review your action and try again"
        },
        [ERROR_TYPES.UNKNOWN]: {
          category: "Unknown",
          suggestions: [
            "Try refreshing the page",
            "Check browser console for details",
            "Contact support with error details",
            "Try again in a few minutes"
          ],
          isRecoverable: true,
          userAction: "Unexpected error - please try again"
        }
      };
      return analysisMap[error.type] || analysisMap[ERROR_TYPES.UNKNOWN];
    }
    /**
     * Handle and normalize any error
     */
    static handleError(error, context = "unknown") {
      if (error instanceof StandardError) {
        return error;
      }
      let message = "An unexpected error occurred";
      let type = ERROR_TYPES.UNKNOWN;
      let severity = ERROR_SEVERITY.MEDIUM;
      const details = { context };
      if (error instanceof Error) {
        message = error.message;
        details.originalError = error.name;
        details.stack = this.sanitizeStackTrace(error.stack);
        if (isValidationError(error)) {
          type = ERROR_TYPES.VALIDATION;
          severity = ERROR_SEVERITY.LOW;
        } else if (isNetworkError(error)) {
          type = ERROR_TYPES.NETWORK;
          severity = ERROR_SEVERITY.MEDIUM;
        } else if (isSecurityError(error)) {
          type = ERROR_TYPES.SECURITY;
          severity = ERROR_SEVERITY.HIGH;
        } else if (isSystemError(error)) {
          type = ERROR_TYPES.SYSTEM;
          severity = ERROR_SEVERITY.HIGH;
        } else if (isUserError(error)) {
          type = ERROR_TYPES.USER;
          severity = ERROR_SEVERITY.LOW;
        }
      } else if (typeof error === "string") {
        message = error;
      } else if (error !== null && error !== void 0) {
        message = String(error);
      }
      return new StandardError(message, type, severity, details);
    }
    /**
     * Log error with appropriate level
     */
    static logError(error, component = "unknown") {
      const logData = {
        component,
        error: error.toJSON(),
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      switch (error.severity) {
        case ERROR_SEVERITY.CRITICAL:
          console.error("\u{1F6A8} CRITICAL ERROR:", logData);
          break;
        case ERROR_SEVERITY.HIGH:
          console.error("\u274C HIGH ERROR:", logData);
          break;
        case ERROR_SEVERITY.MEDIUM:
          console.warn("\u26A0\uFE0F MEDIUM ERROR:", logData);
          break;
        case ERROR_SEVERITY.LOW:
          console.info("\u2139\uFE0F LOW ERROR:", logData);
          break;
        default:
          console.error("\u2753 UNKNOWN ERROR:", logData);
      }
    }
    /**
     * Show error to user via notification system
     */
    static showErrorToUser(error, component = "unknown") {
      if (typeof window !== "undefined" && window.Alpine?.store("notifications")) {
        let notificationType = "error";
        switch (error.severity) {
          case ERROR_SEVERITY.CRITICAL:
          case ERROR_SEVERITY.HIGH:
            notificationType = "error";
            break;
          case ERROR_SEVERITY.MEDIUM:
            notificationType = "warning";
            break;
          case ERROR_SEVERITY.LOW:
            notificationType = "info";
            break;
        }
        const notificationStore = window.Alpine.store("notifications");
        notificationStore.add(
          error.userMessage,
          notificationType,
          error.severity === ERROR_SEVERITY.CRITICAL ? 1e4 : 5e3
        );
      }
      if (typeof window !== "undefined" && window.Alpine?.store("errorBoundary")) {
        const errorBoundaryStore = window.Alpine.store("errorBoundary");
        errorBoundaryStore.addError(error, component, "unknown");
      }
    }
    /**
     * Process error through complete error handling pipeline
     */
    static processError(error, component = "unknown", context = "unknown") {
      const standardError = this.handleError(error, context);
      this.logError(standardError, component);
      this.showErrorToUser(standardError, component);
      return standardError;
    }
  };
  function setupGlobalErrorHandling() {
    if (typeof window === "undefined")
      return;
    window.addEventListener("unhandledrejection", (event) => {
      const error = ErrorHandler.processError(
        event.reason,
        "global",
        "unhandledrejection"
      );
      console.error("Unhandled promise rejection:", error);
      event.preventDefault();
    });
    window.addEventListener("error", (event) => {
      const error = ErrorHandler.processError(
        event.error || event.message,
        "global",
        "global_error"
      );
      console.error("Global error:", error);
    });
    document.addEventListener("alpine:error", (event) => {
      const customEvent = event;
      const error = ErrorHandler.processError(
        customEvent.detail.error,
        "alpine",
        "alpine_error"
      );
      console.error("Alpine.js error:", error);
    });
  }
  if (typeof window !== "undefined") {
    setupGlobalErrorHandling();
  }

  // static/js/components/echo-tool.ts
  function echoTool() {
    return {
      /** The input message to echo */
      message: "Hello from the MCP Dashboard!",
      /** The result of the last echo execution */
      result: null,
      /** The execution time of the last command */
      executionTime: null,
      /** Form validation errors */
      errors: {},
      /** The tool executor instance */
      executor: null,
      /**
       * Validates and sanitizes user input for security
       */
      validateAndSanitizeInput(input) {
        const errors = [];
        if (!input || typeof input !== "string") {
          errors.push("Message must be a non-empty string");
          return { valid: false, errors, sanitized: "" };
        }
        if (input.length > 1e3) {
          errors.push("Message too long (max 1000 characters)");
        }
        const dangerousPatterns = [
          /<script[^>]*>/i,
          /javascript:/i,
          /vbscript:/i,
          /onload\s*=/i,
          /onerror\s*=/i
        ];
        for (const pattern of dangerousPatterns) {
          if (pattern.test(input)) {
            errors.push("Message contains potentially dangerous content");
            break;
          }
        }
        return {
          valid: errors.length === 0,
          errors,
          sanitized: input.trim()
        };
      },
      /**
       * Initialize the component
       * Sets up the tool executor instance from the Alpine store
       */
      init() {
        this.executor = this.$store.toolExecution.getExecutor("echo");
      },
      /**
       * Get the current loading state of the tool executor
       */
      get loading() {
        return this.executor ? this.executor.loading : false;
      },
      /**
       * Get the execution history from the tool executor
       */
      get executionHistory() {
        return this.executor ? this.executor.executionHistory : [];
      },
      /**
       * Execute the echo tool with the current message
       * 
       * Validates input, executes the tool, and handles the response.
       * Updates the result and execution time on success, or shows errors on failure.
       */
      async execute() {
        try {
          if (!this.validateForm())
            return;
          if (!this.executor) {
            this.executor = this.$store.toolExecution?.getExecutor("echo");
            if (!this.executor) {
              throw new Error("Tool executor not available");
            }
          }
          const result = await this.executor.execute({ message: this.message });
          if (result.success) {
            this.result = JSON.stringify(result.result, null, 2);
            this.executionTime = `Executed in ${this.executor.lastResult?.duration || 0}ms`;
          } else {
            this.result = null;
            this.executionTime = null;
            if (this.$store.notifications) {
              this.$store.notifications.add(
                `Tool execution failed: ${result.error || "Unknown error"}`,
                "error"
              );
            }
          }
        } catch (error) {
          this.handleExecutionError(error);
        }
      },
      /**
       * Handle execution errors with centralized error processing
       */
      handleExecutionError(error) {
        const standardError = ErrorHandler.processError(
          error,
          "echoTool",
          "execute"
        );
        this.result = null;
        this.executionTime = null;
        if (error.message && error.message.includes("validation")) {
          const validationError = ErrorHandler.createValidationError(
            "Please check your input and try again.",
            { originalError: error.message }
          );
          ErrorHandler.showErrorToUser(validationError, "echoTool");
        }
      },
      /**
       * Validate the form input before execution
       */
      validateForm() {
        this.errors = {};
        const validation = this.validateAndSanitizeInput(this.message);
        if (!validation.valid) {
          this.errors.message = validation.errors.join(", ");
          return false;
        }
        this.message = validation.sanitized;
        return true;
      },
      /**
       * Clear the execution history
       * 
       * Clears all previous execution results from the tool executor.
       * Handles any errors that occur during the clearing process.
       */
      clearHistory() {
        try {
          if (this.executor) {
            this.executor.clearHistory();
          }
        } catch (error) {
          ErrorHandler.processError(error, "echoTool", "clearHistory");
        }
      },
      /**
       * Get the success rate of tool executions
       */
      getSuccessRate() {
        try {
          return this.executor ? this.executor.getSuccessRate() : 0;
        } catch (error) {
          ErrorHandler.processError(error, "echoTool", "getSuccessRate");
          return 0;
        }
      },
      /**
       * Get the average execution time of tool executions
       */
      getAverageExecutionTime() {
        try {
          return this.executor ? this.executor.getAverageExecutionTime() : 0;
        } catch (error) {
          ErrorHandler.processError(error, "echoTool", "getAverageExecutionTime");
          return 0;
        }
      }
    };
  }

  // static/js/components/metrics-dashboard.ts
  function metricsStore() {
    return {
      /**
       * Get the current metrics data from the store
       */
      get metrics() {
        return this.$store.metrics.data;
      },
      /**
       * Get the current loading state from the store
       */
      get loading() {
        return this.$store.metrics.loading;
      },
      /**
       * Initialize metrics updates by setting loading state
       */
      initializeUpdates() {
        this.$store.metrics.setLoading(true);
      },
      /**
       * Update metrics data from an event
       */
      updateMetrics(event) {
        try {
          const data = JSON.parse(event.detail.xhr.response);
          this.$store.metrics.update(data);
        } catch (error) {
          const standardError = ErrorHandler.processError(
            error,
            "metricsStore",
            "updateMetrics_json_parsing"
          );
          ErrorHandler.showErrorToUser(standardError, "metricsStore");
          this.$store.metrics.setLoading(false);
        }
      }
    };
  }
  document.addEventListener("alpine:init", () => {
    if (typeof window !== "undefined" && window.Alpine) {
      window.Alpine.store("metrics", {
        /** Current metrics data */
        data: {
          total_tool_calls: 0,
          success_rate: 0,
          active_sessions: 0,
          avg_duration_ms: 0,
          tools_available: 0,
          resources_available: 0
        },
        /** Loading state indicator */
        loading: false,
        /** Error state */
        error: null,
        /** Historical metrics data */
        history: [],
        /**
         * Update metrics data with new values
         */
        update(newData) {
          this.data = { ...this.data, ...newData };
          this.loading = false;
          this.addMetric({
            timestamp: Date.now(),
            value: newData.total_tool_calls,
            type: "update",
            total_tool_calls: newData.total_tool_calls,
            success_rate: newData.success_rate
          });
        },
        /**
         * Set the loading state
         */
        setLoading(state) {
          this.loading = state;
        },
        /**
         * Set the error state
         */
        setError(error) {
          this.error = error;
        },
        /**
         * Add a metric to the history
         */
        addMetric(metric) {
          this.history.push(metric);
          if (this.history.length > 100) {
            this.history.shift();
          }
        },
        /**
         * Clear all metrics data
         */
        clear() {
          this.data = {
            total_tool_calls: 0,
            success_rate: 0,
            active_sessions: 0,
            avg_duration_ms: 0,
            tools_available: 0,
            resources_available: 0
          };
          this.history = [];
          this.loading = false;
          this.error = null;
        },
        /**
         * Get metrics by type
         */
        getByType(type) {
          return this.history.filter((metric) => metric.type === type);
        },
        /**
         * Get the latest metric of a specific type
         */
        getLatest(type) {
          const metrics = this.getByType(type);
          return metrics.length > 0 ? metrics[metrics.length - 1] : void 0;
        },
        /**
         * Get metrics within a time range
         */
        getMetricsInRange(startTime, endTime) {
          return this.history.filter(
            (metric) => metric.timestamp >= startTime && metric.timestamp <= endTime
          );
        },
        /**
         * Calculate average value for a metric type
         */
        getAverageValue(type) {
          const metrics = this.getByType(type);
          if (metrics.length === 0)
            return 0;
          const sum = metrics.reduce((acc, metric) => acc + metric.value, 0);
          return sum / metrics.length;
        }
      });
    }
  });

  // static/js/components/event-stream.ts
  function eventStream() {
    return {
      /**
       * Get all events from the event stream store
       */
      get events() {
        return this.$store.eventStream.events;
      },
      /**
       * Initialize server-sent events (SSE)
       * 
       * Note: SSE initialization is handled by HTMX
       */
      initializeSSE() {
      },
      /**
       * Handle incoming SSE messages
       */
      handleSSEMessage(event) {
        try {
          const data = JSON.parse(event.detail.data);
          const sanitizedData = this.sanitizeEventData(data);
          this.$store.eventStream.addEvent(sanitizedData);
        } catch (error) {
          this.handleEventStreamError(error, "handleSSEMessage", [event]);
        }
      },
      /**
       * Handle event stream errors with recovery mechanism
       */
      handleEventStreamError(error, method, args = []) {
        const standardError = ErrorHandler.processError(
          error,
          "eventStream",
          `${method}_event_stream_processing`
        );
        ErrorHandler.showErrorToUser(standardError, "eventStream");
        try {
          this.$store.eventStream.addEvent({
            type: "error",
            message: "Error processing event stream",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        } catch (fallbackError) {
          ErrorHandler.processError(
            fallbackError,
            "eventStream",
            "fallbackErrorEvent"
          );
        }
      },
      /**
       * Sanitize event data to prevent XSS attacks
       */
      sanitizeEventData(data) {
        try {
          const sanitized = {};
          const allowedProps = ["type", "name", "message", "uri", "timestamp"];
          for (const prop of allowedProps) {
            if (data[prop] !== void 0) {
              sanitized[prop] = this.sanitizeString(data[prop]);
            }
          }
          if (sanitized.timestamp && !isNaN(Date.parse(sanitized.timestamp))) {
            sanitized.timestamp = new Date(sanitized.timestamp).toISOString();
          } else {
            sanitized.timestamp = (/* @__PURE__ */ new Date()).toISOString();
          }
          const result = {
            type: sanitized.type || "unknown",
            timestamp: sanitized.timestamp,
            ...sanitized
          };
          return result;
        } catch (error) {
          this.handleEventStreamError(error, "sanitizeEventData", [data]);
          return {
            type: "error",
            message: "Failed to process event data",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
        }
      },
      /**
       * Sanitize a string value to prevent XSS
       */
      sanitizeString(value) {
        if (typeof value !== "string") {
          return String(value);
        }
        if (value.length > 500) {
          value = value.substring(0, 500) + "...";
        }
        const div = document.createElement("div");
        div.textContent = value;
        return div.innerHTML;
      },
      /**
       * Get CSS classes for an event based on its type
       */
      getEventClass(type) {
        const classes = {
          "error": "bg-red-900 bg-opacity-30 text-red-300 border-red-500",
          "tool_called": "bg-green-900 bg-opacity-30 text-green-300 border-green-500",
          "default": "bg-blue-900 bg-opacity-30 text-blue-300 border-blue-500"
        };
        return classes[type] || classes.default;
      },
      /**
       * Format an event object into a display string
       */
      formatEvent(event) {
        try {
          const timestamp = new Date(event.timestamp).toLocaleTimeString();
          let message = `[${timestamp}] ${event.type || "unknown"}`;
          if (event.name)
            message += `: ${event.name}`;
          if (event.message)
            message += `: ${event.message}`;
          if (event.uri)
            message += `: ${event.uri}`;
          if (event.id)
            message += ` (${event.id})`;
          return message;
        } catch (error) {
          return "[Invalid event data]";
        }
      }
    };
  }
  document.addEventListener("alpine:init", () => {
    if (typeof window !== "undefined" && window.Alpine) {
      window.Alpine.store("eventStream", {
        /** Array of event objects */
        events: [],
        /** Maximum number of events to keep in memory */
        maxEvents: 20,
        /**
         * Add a new event to the stream
         */
        addEvent(event) {
          if (!event || typeof event !== "object") {
            if (true) {
              console.warn("Invalid event data received");
            }
            return;
          }
          const eventWithId = {
            ...event,
            id: (Date.now() + Math.random()).toString()
          };
          this.events.unshift(eventWithId);
          if (this.events.length > this.maxEvents) {
            this.events.pop();
          }
        },
        /**
         * Clear all events from the stream
         */
        clear() {
          this.events = [];
        }
      });
    }
  });

  // static/js/components/notification-system.ts
  function notificationSystem() {
    return {
      /** Whether the component has encountered an error */
      hasError: false,
      /** Current error message */
      errorMessage: null,
      /** Reference to the error event handler for cleanup */
      _errorHandler: null,
      /**
       * Initialize the notification system component
       * Sets up error handling wrappers for critical methods
       */
      init() {
        this.setupErrorHandling();
      },
      /**
       * Set up error handling wrappers for component methods
       * 
       * Wraps critical methods with try-catch blocks to prevent
       * component crashes and provide graceful error handling.
       */
      setupErrorHandling() {
        const originalRemove = this.remove;
        this.remove = (id) => {
          try {
            return originalRemove.call(this, id);
          } catch (error) {
            this.handleComponentError(error, "remove", [id]);
          }
        };
        this._errorHandler = (event) => {
          this.handleComponentError(event.error || new Error(event.message), "globalError");
        };
        window.addEventListener("error", this._errorHandler);
      },
      /**
       * Get all notifications from the store
       */
      get notifications() {
        try {
          return this.$store.notifications?.items || [];
        } catch (error) {
          this.handleComponentError(error, "notifications getter");
          return [];
        }
      },
      /**
       * Remove a notification by ID
       */
      remove(id) {
        try {
          this.$store.notifications.remove(id.toString());
        } catch (error) {
          this.handleComponentError(error, "remove", [id]);
        }
      },
      /**
       * Get CSS classes for a notification based on its type
       */
      getNotificationClass(type) {
        try {
          const classes = {
            "success": "bg-green-900 text-green-300 border-green-700",
            "error": "bg-red-900 text-red-300 border-red-700",
            "warning": "bg-yellow-900 text-yellow-300 border-yellow-700",
            "info": "bg-blue-900 text-blue-300 border-blue-700"
          };
          return classes[type] || classes.info;
        } catch (error) {
          this.handleComponentError(error, "getNotificationClass", [type]);
          return "bg-blue-900 text-blue-300 border-blue-700";
        }
      },
      /**
       * Handle component errors with recovery mechanism
       */
      handleComponentError(error, method, args = []) {
        this.hasError = true;
        this.errorMessage = error.message || "Notification component error";
        const standardError = ErrorHandler.processError(
          error,
          "notificationSystem",
          method
        );
        if (true) {
          console.error("Notification System Error:", standardError.toJSON());
        }
        setTimeout(() => {
          this.recoverFromError();
        }, 2e3);
      },
      /**
       * Recover from component errors
       * 
       * Resets error state and attempts to reinitialize the component.
       */
      recoverFromError() {
        this.hasError = false;
        this.errorMessage = null;
        try {
          this.setupErrorHandling();
        } catch (error) {
          if (true) {
            console.error("Failed to recover notification system:", error);
          }
        }
      },
      /**
       * Destroy the notification system
       */
      destroy() {
        this.$store.notifications.clear();
        if (this._errorHandler) {
          window.removeEventListener("error", this._errorHandler);
          this._errorHandler = null;
        }
      }
    };
  }
  function escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  function sanitizeMessage(message) {
    if (typeof message !== "string") {
      return "Invalid message format";
    }
    if (message.length > 1e3) {
      message = message.substring(0, 1e3) + "...";
    }
    return escapeHtml(message);
  }
  document.addEventListener("alpine:init", () => {
    if (typeof window !== "undefined" && window.Alpine) {
      window.Alpine.store("notifications", {
        /** Array of active notification objects */
        items: [],
        /**
         * Add a new notification to the store
         */
        add(message, type = "info", duration = 5e3) {
          try {
            const sanitizedMessage = sanitizeMessage(message);
            const validTypes = ["success", "error", "warning", "info"];
            const sanitizedType = validTypes.includes(type) ? type : "info";
            const sanitizedDuration = Math.max(0, Math.min(duration, 3e4));
            const notification = {
              id: (Date.now() + Math.random()).toString(),
              message: sanitizedMessage,
              type: sanitizedType,
              timestamp: Date.now(),
              duration: sanitizedDuration
            };
            this.items.push(notification);
            if (sanitizedDuration > 0) {
              setTimeout(() => {
                this.remove(notification.id);
              }, sanitizedDuration);
            }
          } catch (error) {
            if (true) {
              console.error("Error adding notification:", error);
            }
            this.items.push({
              id: (Date.now() + Math.random()).toString(),
              message: "Error processing notification",
              type: "error",
              timestamp: Date.now(),
              duration: 5e3
            });
          }
        },
        /**
         * Remove a notification by ID
         */
        remove(id) {
          this.items = this.items.filter((item) => item.id !== id);
        },
        /**
         * Clear all notifications
         */
        clear() {
          this.items = [];
        },
        /**
         * Get notifications by type
         */
        getByType(type) {
          return this.items.filter((item) => item.type === type);
        },
        /**
         * Get notification count
         */
        getCount() {
          return this.items.length;
        },
        /**
         * Get notification count by type
         */
        getCountByType(type) {
          return this.items.filter((item) => item.type === type).length;
        }
      });
    }
  });

  // static/js/components/tool-executor.ts
  function toolExecutor(toolName) {
    return {
      toolName,
      loading: false,
      lastResult: null,
      executionHistory: [],
      async execute(args = {}) {
        this.loading = true;
        const executionId = (Date.now() + Math.random()).toString();
        const startTime = Date.now();
        try {
          const response = await fetch("/api/tools/execute", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: this.toolName,
              arguments: args
            })
          });
          const data = await response.json();
          const endTime = Date.now();
          const duration = endTime - startTime;
          this.lastResult = {
            id: executionId,
            success: data.success,
            result: data.result,
            error: data.error,
            duration,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            args
          };
          this.executionHistory.unshift(this.lastResult);
          if (this.executionHistory.length > 10) {
            this.executionHistory.pop();
          }
          if (data.success) {
            this.$store.notifications.add(
              `Tool "${this.toolName}" executed successfully (${duration}ms)`,
              "success"
            );
            this.$store.dashboard.refreshAll();
          } else {
            this.$store.notifications.add(
              `Tool execution failed: ${data.error}`,
              "error"
            );
          }
          return data;
        } catch (error) {
          const standardError = ErrorHandler.processError(
            error,
            "toolExecutor",
            `execute_${this.toolName}`
          );
          const errorResult = {
            id: executionId,
            success: false,
            error: standardError.message,
            duration: Date.now() - startTime,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            args
          };
          this.lastResult = errorResult;
          this.executionHistory.unshift(errorResult);
          ErrorHandler.showErrorToUser(standardError, "toolExecutor");
          throw standardError;
        } finally {
          this.loading = false;
        }
      },
      getSuccessRate() {
        if (this.executionHistory.length === 0)
          return 0;
        const successful = this.executionHistory.filter((h) => h.success).length;
        return Math.round(successful / this.executionHistory.length * 100);
      },
      getAverageExecutionTime() {
        if (this.executionHistory.length === 0)
          return 0;
        const total = this.executionHistory.reduce((sum, h) => sum + h.duration, 0);
        return Math.round(total / this.executionHistory.length);
      },
      clearHistory() {
        this.executionHistory = [];
        this.lastResult = null;
      }
    };
  }
  if (typeof window !== "undefined") {
    window.addEventListener("alpine:init", () => {
      if (window.Alpine) {
        window.Alpine.store("toolExecution", {
          activeExecutions: /* @__PURE__ */ new Map(),
          getExecutor(toolName) {
            if (!this.activeExecutions.has(toolName)) {
              this.activeExecutions.set(toolName, toolExecutor(toolName));
            }
            return this.activeExecutions.get(toolName);
          },
          async executeGlobal(toolName, args = {}) {
            const executor = this.getExecutor(toolName);
            return await executor.execute(args);
          },
          getToolStats(toolName) {
            const executor = this.activeExecutions.get(toolName);
            if (!executor)
              return null;
            return {
              executions: executor.executionHistory.length,
              successRate: executor.getSuccessRate(),
              averageTime: executor.getAverageExecutionTime(),
              lastResult: executor.lastResult
            };
          },
          getAllStats() {
            const stats = {};
            this.activeExecutions.forEach((executor, toolName) => {
              const toolStats = this.getToolStats(toolName);
              if (toolStats) {
                stats[toolName] = toolStats;
              }
            });
            return stats;
          },
          /**
           * Clear all execution history
           */
          clearAllHistory() {
            this.activeExecutions.forEach((executor) => {
              executor.clearHistory();
            });
          },
          /**
           * Get total execution count across all tools
           */
          getTotalExecutions() {
            let total = 0;
            this.activeExecutions.forEach((executor) => {
              total += executor.executionHistory.length;
            });
            return total;
          },
          /**
           * Get overall success rate across all tools
           */
          getOverallSuccessRate() {
            let totalExecutions = 0;
            let successfulExecutions = 0;
            this.activeExecutions.forEach((executor) => {
              totalExecutions += executor.executionHistory.length;
              successfulExecutions += executor.executionHistory.filter((h) => h.success).length;
            });
            return totalExecutions > 0 ? Math.round(successfulExecutions / totalExecutions * 100) : 0;
          }
        });
      }
    });
  }

  // static/js/components/htmx-alpine-bridge.ts
  function getStore(name) {
    return window.Alpine.store(name);
  }
  function initializeHtmxAlpineBridge() {
    document.body.addEventListener("htmx:afterSwap", function(event) {
      const htmxEvent = event;
      const target = htmxEvent.detail.target;
      if (target.id === "metrics-data") {
        try {
          const data = JSON.parse(htmxEvent.detail.xhr.response);
          getStore("metrics").update(data);
        } catch (error) {
          console.error("Error parsing metrics data:", error);
          getStore("notifications").add("Error updating metrics", "error");
        }
      }
      if (target.id === "status-data") {
        try {
          const data = JSON.parse(htmxEvent.detail.xhr.response);
          getStore("status").update(data);
        } catch (error) {
          console.error("Error parsing status data:", error);
        }
      }
      if (target.id === "tool-calls-data") {
        try {
          const data = JSON.parse(htmxEvent.detail.xhr.response);
          getStore("toolCalls").update(data);
        } catch (error) {
          console.error("Error parsing tool calls data:", error);
        }
      }
    });
    document.body.addEventListener("htmx:beforeRequest", function(event) {
      const htmxEvent = event;
      const target = htmxEvent.detail.target;
      if (target.id === "metrics-data") {
        getStore("metrics").setLoading(true);
      }
      if (target.id === "status-data") {
        getStore("status").setLoading(true);
      }
    });
    document.body.addEventListener("htmx:responseError", function(event) {
      const htmxEvent = event;
      const status = htmxEvent.detail.xhr.status;
      const target = htmxEvent.detail.target;
      let message = `Request failed (${status})`;
      if (target.id === "metrics-data") {
        message = "Failed to load metrics";
        getStore("metrics").setLoading(false);
      } else if (target.id === "status-data") {
        message = "Failed to load server status";
        getStore("status").setLoading(false);
      }
      getStore("notifications").add(message, "error");
    });
    document.body.addEventListener("htmx:sseMessage", function(event) {
      const htmxEvent = event;
      try {
        const data = JSON.parse(htmxEvent.detail.data || "{}");
        getStore("eventStream").addEvent(data);
      } catch (error) {
        console.error("Error parsing SSE message:", error);
      }
    });
    document.body.addEventListener("htmx:sseOpen", function(event) {
      getStore("notifications").add("Live events connected", "success");
      getStore("dashboard").setSSEConnected(true);
    });
    document.body.addEventListener("htmx:sseError", function(event) {
      getStore("notifications").add("Live events connection error", "error");
      getStore("dashboard").setSSEConnected(false);
    });
    document.body.addEventListener("htmx:sseClose", function(event) {
      getStore("notifications").add("Live events disconnected", "warning");
      getStore("dashboard").setSSEConnected(false);
    });
  }
  document.addEventListener("alpine:init", () => {
    const dashboardStore = {
      sseConnected: false,
      lastUpdate: null,
      setSSEConnected(connected) {
        this.sseConnected = connected;
      },
      triggerUpdate(endpoint) {
        if (typeof window !== "undefined" && window.htmx) {
          window.htmx.trigger(`#${endpoint}-data`, "htmx:trigger");
          this.lastUpdate = (/* @__PURE__ */ new Date()).toISOString();
        }
      },
      refreshAll() {
        this.triggerUpdate("metrics");
        this.triggerUpdate("status");
        this.triggerUpdate("tool-calls");
      }
    };
    window.Alpine.store("dashboard", dashboardStore);
    const statusStore = {
      data: {},
      loading: false,
      update(newData) {
        this.data = { ...this.data, ...newData };
        this.loading = false;
      },
      setLoading(state) {
        this.loading = state;
      }
    };
    window.Alpine.store("status", statusStore);
    const toolCallsStore = {
      data: [],
      loading: false,
      update(newData) {
        this.data = Array.isArray(newData) ? newData : [];
        this.loading = false;
      },
      setLoading(state) {
        this.loading = state;
      }
    };
    window.Alpine.store("toolCalls", toolCallsStore);
  });

  // static/js/components/dashboard-controls.ts
  function dashboardControls() {
    return {
      refreshing: false,
      autoRefresh: true,
      refreshInterval: 2e3,
      intervalId: null,
      init() {
        this.startAutoRefresh();
      },
      async refreshAll() {
        this.refreshing = true;
        try {
          const dashboardStore = this.$store.dashboard;
          dashboardStore.refreshAll();
          this.$store.notifications.add("Dashboard refreshed", "success");
        } catch (error) {
          const standardError = ErrorHandler.processError(
            error,
            "dashboardControls",
            "refreshAll_manual_refresh"
          );
          ErrorHandler.showErrorToUser(standardError, "dashboardControls");
        } finally {
          this.refreshing = false;
        }
      },
      toggleAutoRefresh() {
        this.autoRefresh = !this.autoRefresh;
        if (this.autoRefresh) {
          this.startAutoRefresh();
          this.$store.notifications.add("Auto-refresh enabled", "info");
        } else {
          this.stopAutoRefresh();
          this.$store.notifications.add("Auto-refresh disabled", "info");
        }
      },
      startAutoRefresh() {
        if (this.intervalId) {
          clearInterval(this.intervalId);
        }
        if (this.autoRefresh) {
          this.intervalId = setInterval(() => {
            if (!this.refreshing) {
              this.$store.dashboard.refreshAll();
            }
          }, this.refreshInterval);
        }
      },
      stopAutoRefresh() {
        if (this.intervalId) {
          clearInterval(this.intervalId);
          this.intervalId = null;
        }
      },
      setRefreshInterval(interval) {
        this.refreshInterval = interval;
        if (this.autoRefresh) {
          this.startAutoRefresh();
        }
      },
      async clearAllData() {
        try {
          this.$store.metrics.data = {
            total_tool_calls: 0,
            success_rate: 0,
            active_sessions: 0,
            avg_duration_ms: 0,
            tools_available: 0,
            resources_available: 0
          };
          this.$store.eventStream.clear();
          this.$store.notifications.clear();
          const toolExecutionStore = this.$store.toolExecution;
          if (toolExecutionStore && toolExecutionStore.activeExecutions) {
            toolExecutionStore.activeExecutions.forEach((executor) => {
              if (executor.clearHistory) {
                executor.clearHistory();
              }
            });
          }
          this.$store.notifications.add("All data cleared", "success");
        } catch (error) {
          const standardError = ErrorHandler.processError(
            error,
            "dashboardControls",
            "clearAllData_data_clear"
          );
          ErrorHandler.showErrorToUser(standardError, "dashboardControls");
        }
      },
      exportData() {
        try {
          const data = {
            metrics: this.$store.metrics.data,
            events: this.$store.eventStream.events,
            toolStats: this.$store.toolExecution?.getAllStats ? this.$store.toolExecution.getAllStats() : {},
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `mcp-dashboard-export-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
          a.click();
          URL.revokeObjectURL(url);
          this.$store.notifications.add("Data exported successfully", "success");
        } catch (error) {
          const standardError = ErrorHandler.processError(
            error,
            "dashboardControls",
            "exportData_data_export"
          );
          ErrorHandler.showErrorToUser(standardError, "dashboardControls");
        }
      },
      get connectionStatus() {
        return this.$store.dashboard.sseConnected ? "connected" : "disconnected";
      },
      get lastUpdate() {
        return this.$store.dashboard.lastUpdate;
      }
    };
  }
  function enhancedEventStream() {
    const baseEventStream = eventStream();
    return {
      ...baseEventStream,
      pauseStream: false,
      maxEvents: 50,
      togglePause() {
        this.pauseStream = !this.pauseStream;
        if (this.pauseStream) {
          this.$store.notifications.add("Event stream paused", "info");
        } else {
          this.$store.notifications.add("Event stream resumed", "info");
        }
      },
      handleSSEMessage(event) {
        if (this.pauseStream)
          return;
        try {
          const data = JSON.parse(event.detail.data);
          this.$store.eventStream.addEvent(data);
          if (data.type === "tool_called") {
            const dashboardStore = this.$store.dashboard;
            if (dashboardStore.triggerUpdate) {
              dashboardStore.triggerUpdate("metrics");
              dashboardStore.triggerUpdate("tool-calls");
            }
          }
        } catch (error) {
          ErrorHandler.processError(
            error,
            "dashboardControls",
            "initSSE_sse_message_parsing"
          );
        }
      },
      filterEvents(type) {
        return this.$store.eventStream.events.filter(
          (event) => type === "all" || event.type === type
        );
      },
      clearEvents() {
        this.$store.eventStream.clear();
        this.$store.notifications.add("Events cleared", "info");
      }
    };
  }

  // static/js/alpine-components.ts
  setupGlobalErrorHandling();
  window.echoTool = echoTool;
  window.metricsStore = metricsStore;
  window.eventStream = eventStream;
  window.notificationSystem = notificationSystem;
  window.toolExecutor = (toolName) => toolExecutor(toolName || "default");
  window.dashboardControls = dashboardControls;
  window.enhancedEventStream = enhancedEventStream;
  document.addEventListener("DOMContentLoaded", () => {
    try {
      if (window.Alpine) {
        window.Alpine.start();
        console.log("Alpine.js initialized successfully");
      } else {
        throw new Error("Alpine.js not found. Please include Alpine.js before this script.");
      }
    } catch (error) {
      ErrorHandler.processError(error, "AlpineInit", "initialization");
    }
  });
  document.addEventListener("alpine:init", () => {
    try {
      initializeHtmxAlpineBridge();
      console.log("HTMX-Alpine bridge initialized");
    } catch (error) {
      ErrorHandler.processError(error, "HTMXAlpineBridge", "initialization");
    }
  });
})();
//# sourceMappingURL=dashboard.min.js.map
